<!DOCTYPE html>
<html>
<head>
    <meta name="ROBOTS" content="INDEX, FOLLOW"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <meta name="description" content="Formation React js, avec ES6"/>
    <meta
            name="keywords"
            content="formation react, formation reactjs, freelance, flux, redux, es6, props, state, jsx"
    />
    <link rel="canonical" href="https://formation-reactjs.fr"/>
    <title>Formation react js ES6</title>

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>

    <link rel="stylesheet" href="reveal/reset.css"/>
    <link rel="stylesheet" href="reveal/reveal.css"/>
    <link rel="stylesheet" href="reveal/theme/black.css" id="theme"/>

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="reveal/plugin/highlight/monokai.css" id="highlight-theme"/>

    <style type="text/css">
        p {
            text-align: left;
        }

        .reveal h3,
        .reveal h4 {
            text-transform: none;
        }

        .reveal pre code {
            max-height: 530px;
        }
    </style>
</head>
<body>
<div class="reveal">
    <div class="slides">
        <section>
            <h1>
                <img
                        width="75"
                        height="75"
                        data-src="images/react.svg"
                        alt="react"
                        style="border: none; background: none; box-shadow: none; margin: 0"
                />React
            </h1>
            <h3>#ES6</h3>
            <p style="text-align: center"><a target="_blank" href="http://twitter.com/jbcazaux">@jbcazaux</a></p>

            <a href="https://www.netlify.com">
                <img
                        src="https://www.netlify.com/img/global/badges/netlify-color-bg.svg"
                        alt="Deploys by Netlify"
                        style="border: none; background: none; box-shadow: none; margin: 0; float: right"
                />
            </a>
        </section>
        <section data-visibility="hidden"><img data-src="images/mynameis.jpg" alt="my name is"/></section>
        <section data-visibility="hidden"><img data-src="images/coffee.gif" alt="coffee break"/></section>
        <section data-visibility="hidden">
            <h3>Objectifs</h3>
            <img data-src="images/postits.jpg" alt="goals"/>
        </section>
        <section>
            <h3>Versions</h3>
            <pre><code data-trim>"react": "17.0.1"</code></pre>
        </section>
        <section>
            <h3>Le programme !</h3>
            <ul>
                <li>
                    ES6/7
                    <ul>
                        <li>ES6/7</li>
                        <li>Programmation fonctionnelle</li>
                    </ul>
                </li>
                <li>
                    ReactJS
                    <ul>
                        <li>Principes de base</li>
                        <li>Composants</li>
                        <li>Gestion de la donnée</li>
                        <li>Redux</li>
                        <li>Tests</li>
                        <li>Routing</li>
                        <li>Optimisations</li>
                    </ul>
                </li>
            </ul>
        </section>
        <section>
            <h2>EcmaScript 6/7</h2>
        </section>
        <section>
            <h3><span style="text-decoration: line-through">var</span>, let, const</h3>
            <pre><code data-trim>
                let foo = 'bar'
                const MAX = 10
                const ttc = addTva(15)
                </code></pre>
            <p class="fragment">
                <span style="color: #8cd0d3">let</span> vs. <span style="color: #cc9393">const</span> ?
                <span class="fragment">0 var, 44 let, 997 const</span>
            </p>
        </section>
        <section>
            <h3><span style="text-decoration: line-through">var</span>, let, const</h3>
            <pre><code data-trim>
                if (true) {
                    var i = 1
                } else {
                    var j = 2
                }
                console.log(i, j)
                </code></pre>
            <pre class="fragment fade-up"><code data-trim>
                const user = {}
                user.name = 'john' // (1)
                user = {name: 'lea'} // (2)
                </code></pre>
            <pre class="fragment fade-up"><code data-trim>
                const arr = ['a']
                arr.push('b') // (3)
                arr = ['a', 'b'] // (4)
                </code></pre>
        </section>
        <section>
            <h3>Arrow functions</h3>
            <pre><code data-trim>
                function addOldSchool(a, b) {
                    return a + b
                }
            </code></pre>
            <pre class="fragment"><code data-trim>
                const add = (a, b) => {
                    return a + b
                }
                </code></pre>
            <pre class="fragment"><code data-trim>
                const add = (a, b) => a + b
                </code></pre>
        </section>
        <section>
            <h3>Arrow functions</h3>
            <pre><code data-trim>
                const squares = [0, 1, 2, 3, 4].map(x => x * x)
                console.log(squares)
                </code></pre>
        </section>
        <section>
            <h3>Attention !</h3>
            <p>
                <a target="_blank" href="http://www.webbrowsercompatibility.com/es6/desktop/"
                >Tout n'est pas encore supporté par les navigateurs</a
                >
            </p>
            <ul>
                <li>Polyfill (Array.flatMap(), Array.reduce(), ...)</li>
                <li>Transpiler (=>, let, const, ...)</li>
            </ul>
        </section>
        <section data-visibility="hidden">
            <h3>Immutabilité !</h3>
            <p>Ne mutez pas pendant la formation, s'il vous plaît.</p>
        </section>
        <section>
            <h3>Spread operator</h3>
            <pre><code data-trim>
              const user = {
                  firstname: 'john',
                  nickname: 'ninja',
                  lastname: 'doe',
                  age: 21
              }

              const updatedUser = {...user, firstname: 'toto'}
              console.log(updatedUser) // ?
            </code></pre>
        </section>
        <section data-auto-animate data-visibility="hidden">
            <h3 data-id="code-title">Spread operator</h3>
            <pre data-id="code-animation"><code class="hljs" data-trim>
                const odd = [1, 3, 5, 7, 9]
                const even = [2, 4, 6, 8]
                const all = [0]

                // arr.push([element1[, ...[, elementN]]])
                all.push(odd)
                all.push(even)

                console.log(all) // ?
                </code></pre>
        </section>
        <section data-auto-animate data-visibility="hidden">
            <h3 data-id="code-title">Spread operator</h3>
            <pre data-id="code-animation"><code class="hljs" data-trim>
                const odd = [1, 3, 5, 7, 9]
                const even = [2, 4, 6, 8]
                const all = [0]

                // arr.push([element1[, ...[, elementN]]])
                for (let i = 0; i < odd.length; i++) {
                    all.push(odd[i])
                }
                for (let i = 0; i < even.length; i++) {
                    all.push(even[i])
                }
                console.log(all) // ?
                </code></pre>
        </section>
        <section data-auto-animate>
            <h3 data-id="code-title">Spread operator</h3>
            <pre data-id="code-animation">
        <code class="hljs" data-trim>
                const odd = [1, 3, 5, 7, 9]
                const even = [2, 4, 6, 8]
                const all = [0, ...odd, ...even]
          </code></pre>
        </section>
        <section>
            <h3>Destructuring</h3>
            <pre><code data-trim>
                const foo = {a: 1, b: 2, c: 'bar'}
                const {a} = foo
                console.log(a) // ?
          </code></pre>
        </section>
        <section>
            <h3>Destructuring</h3>
            <pre><code data-trim>
            const user = {
                firstname: 'john',
                nickname: 'ninja',
                lastname: 'doe',
                age: 21
            }

            function getUserName(user) {
                return `${user.firstname} ${user.lastname}`
            }
            console.log(getUserName(user))
            </code></pre>
            <pre class="fragment"><code data-trim>
            function getUserName({firstname, lastname}) {
                return `${firstname} ${lastname}`
            }
            </code></pre>
            <pre class="fragment"><code data-trim>
            const getUserName = ({firstname, lastname}) =>
                `${firstname} ${lastname}`
            </code></pre>
        </section>
        <section>
            <h3>Destructuring - nested</h3>
            <pre><code data-trim>
            const user = {
                firstname: 'john',
                lastname: 'doe',
                address: {
                    street: 'avenue des champs élysées',
                    num: '12'
                }
            }

            function getUserAddress(user) {
             return `${user.address.num} ${user.address.street}`
            }
            </code></pre>
            <pre class="fragment"><code data-trim>
            const getUserAddress = ({address: {num, street}}) =>
                `${num} ${street}`
            </code></pre>
        </section>
        <section>
            <h3>Destructuring - alias</h3>
            <pre><code data-trim>
            const user = {
                firstname: 'john',
                lastname: 'doe',
                address: {
                    street: 'avenue des champs élysées',
                    num: '12'
                }
            }

            const getUserAddress = ({address: {num: foo, street: bar}}) =>
                `${foo} ${bar}`
            </code></pre>
        </section>
        <section>
            <h3>Destructuring - arrays</h3>
            <pre><code data-trim>
            const maths = [x => x + 1, x => x * x, x => x * x * x]
            const [plus1, square] = maths
            plus1(41) // 42
            square(12) // 144
            </code></pre>
        </section>
        <section>
            <h3>Shorthand Notation</h3>
            <pre><code data-trim>
                const foo = 42
                const bar = 1

                const longer = {
                    foo: foo,
                    bar: bar
                }
            </code></pre>
            <pre class="fragment"><code data-trim>
                const shorter = {
                    foo,
                    bar
                }
            </code></pre>
        </section>
        <section>
            <h3>Promesses VS. async - await</h3>
            <pre><code data-trim>
            axios.get('/users/42/items')
                .then(resp => resp.data)
                .then(items => items.map(item => item.id))
                .then(ids => {/* use the ids */})
                .catch(error => console.log(error.toString()))
            </code></pre>
            <pre class="fragment"><code data-trim>
            async function fetchItems {
                try {
                    const response = await axios.get('/users/42/items')
                    const items = response.data
                    const itemIds = items.map(item => item.id))
                    /* use the ids */
                } catch(error){
                    console.log(error.toString())
                }
            }
            </code></pre>
        </section>
        <section>
            <h3>Promesses VS. async - await</h3>
            <pre><code data-trim>
            axios.get('/users/42/items')
                .then(({data : items})) => items.map(item => item.id))
                .then(ids => {/* use the ids */})
                .catch(error => console.log(error.toString()))
            </code></pre>
            <pre><code data-trim>
            async function fetchItems {
              try {
                const {data: items} = await axios.get('/users/42/items')
                const itemIds = items.map(item => item.id))
                /* use the ids */
              } catch(error){
                console.log(error.toString())
              }
            }
            </code></pre>
        </section>
        <section>
            <h3>Rappels - currying</h3>
            <pre><code data-trim>
            const add = function(x) {
                return function(y) {
                    return x + y
                }
            }
            add(2)(3) // ???
          </code></pre>
            <pre class="fragment"><code data-trim>
                const add2 = add(2)
                add2(3) // = ?
            </code></pre>
            <pre class="fragment"><code data-trim>
                const add = x => y => x + y // WTF ?!
            </code></pre>
            <pre class="fragment"><code data-trim>
                const add = x =>
                    y => (x + y)
                // easy !
            </code></pre>
        </section>
        <section>
            <h3>Rappels - this</h3>
            <pre><code data-trim data-noescape>
            function f() {
                this.foo // what is this ?
            }
            </code></pre>
        </section>
        <section>
            <h1>
                <img
                        width="200"
                        height="200"
                        data-src="images/react.svg"
                        alt="react"
                        style="border: none; background: none; box-shadow: none; margin: 0"
                />
            </h1>
        </section>
        <section>
            <h3>Tout est composant</h3>
            <img data-src="images/components.png" alt="components" width="90%"/>
        </section>
        <section>
            <h3>Hello world</h3>
            <pre>Hello.js<code data-trim>
            const Hello = (props) => <div>Hello {props.name} !</div>

            export default Hello
            </code></pre>
            <pre class="fragment">index.js<code class="jsx" data-trim>
            import ReactDOM from "react-dom"
            import Hello from "./Hello"

            ReactDOM.render(
                &lt;Hello name="world"/&gt;,
                document.getElementById('root')
            )
            </code></pre>
        </section>
        <section>
            <h3>JSX</h3>
            <pre><code data-trim>
            (props) => (
                 &lt;li className="contact"&gt;
                      &lt;h2 className="contact-name"&gt;{props.name}&lt;/h2&gt;
                  &lt;/li&gt;
                )
            </code></pre>
            <pre><code data-trim>
            (props) => React.createElement('li', {className: 'contact'},
                    React.createElement('h2',
                        {className: 'contact-name'}, props.name)
                    )
            )
          </code></pre>
        </section>
        <section data-background="#b5533c">
            <h3>TP-01</h3>
            <h4>Hello World</h4>
            <ol>
                <li>Installer l'environnement</li>
                <li>Ecrire le composant Hello</li>
            </ol>
        </section>
        <section>
            <h3>Type checking</h3>
            <p style="font-size: 32px">
                On peut <i>ne rien faire</i>, utiliser
                <a target="_blank" href="https://www.typescriptlang.org/">Typescript</a> ,
                <a target="_blank" href="https://flow.org/">Flow</a>,
                <a target="_blank" href="https://reasonml.github.io/reason-react/">Reason</a>, ou les
                <a target="_blank" href="https://www.npmjs.com/package/prop-types">PropTypes</a>
            </p>
            <pre><code data-trim>
            import PropTypes from 'prop-types'
            const Hello = ({name}) => <h1>Hello {name}!</h1>

            Hello.propTypes = {
                name: PropTypes.string.isRequired,
                truc: PropTypes.bool
            }
            </code></pre>
            <p style="font-size: 22px; text-align: left">
                types: array, bool, func, number, object, string, shape, node, arrayOf(), ...
                <a href="https://reactjs.org/docs/typechecking-with-proptypes.html">
                    https://reactjs.org/docs/typechecking-with-proptypes.html
                </a>
            </p>
        </section>
        <section>
            <h3>Attributs dans les composants</h3>
            <pre><code data-trim>
            const Counter = () => {
                let count = 0

                return &lt;div onClick={() =&gt; count = count + 1}&gt;
                    Count: {count}
                &lt;/div&gt;
            }
            </code></pre>
            <mark>Don't try this at home !</mark>
        </section>
        <section>
            <h3>State</h3>
            <pre><code data-trim>
           const ComponentWithState = (props) => {
            const [count, setCount] = useState(0)
            const [user, setUser] = useState(null)
            const [color, setColor] = useState('green')

            return ...
           }
           </code></pre>
        </section>

        <section>
            <h3>State</h3>
            <p>Pour mettre un état par défaut, on passe un paramètre à useState()</p>
            <pre><code data-trim>
            const [count, setCount] = useState(42)
          </code></pre>
            <p>Mettre à jour un état</p>
            <pre><code data-trim>
            const [count, setCount] = useState(0)
            setCount(10)
            setCount(prevState => prevState + 1)
            </code></pre>
            <p>Récupérer l'état courant</p>
            <pre><code data-trim>
            const [count, setCount] = useState(0)
            count
          </code></pre>
        </section>
        <section>
            <h3>State</h3>
            <pre><code data-trim>
            const Counter = () =>  {
              const [count, setCount] = useState(0)
              return &lt;div onClick={() => setCount(prev => prev + 1)}&gt;
                  Count: {count}
              &lt;/div&gt;
            }
            </code></pre>
        </section>
        <section>
            <h3>Props vs State</h3>

            <p>Props</p>
            <div style="font-size: 30px; text-align: left; margin-left: 50px">
                <ul>
                    <li>Données passées par le composant parent</li>
                </ul>
            </div>

            <p>State</p>
            <div style="font-size: 30px; text-align: left; margin-left: 50px">
                <ul>
                    <li>Données modifiées par l'utilisateur (clics, saisies, ...)</li>
                    <li>Données récupérées d'un web service</li>
                    <li>Faire un maximum de composants sans état</li>
                    <li><strike>Données dérivées des props </strike>(Faire ca dans le composant directement)</li>
                    <li><strike>Composants</strike></li>
                </ul>
            </div>
        </section>
        <section>
            <h3>Class components</h3>
            <pre><code data-trim>
            class ButtonApp extends React.Component {
                state = {count: 0}
                render() {
                    return &lt;div&gt;
                        &lt;div&gt;{this.props.title}&lt;/div&gt;
                        &lt;button&gt;{this.props.label}&lt;/button&gt;
                        &lt;div&gt;{this.state.count}&lt;/div&gt;
                    &lt;/div&gt;
                }
            }
            </code></pre>
        </section>
        <section>
            <h3>Itérer sur un tableau</h3>
            <pre><code data-trim>
            const MyComponent = (props) => (
                &lt;ul&gt;
                {
                    props.items.map(item =>
                        &lt;li key={item.id}&gt;{item.label}&lt;/li&gt;)
                }
                &lt;/ul&gt;
            )
            </code></pre>
        </section>
        <section>
            <h3>useEffect</h3>
            <p>Déclenche un traitement lorsque des données (issues des props ou des states) changent</p>
            <pre><code data-trim>
            const UserDetails = ({userId}) => {
             const [details, setDetails] = useState(null)

             useEffect(() => {
              axios.get('/users/' + userId)
               .then(({data}}) => setDetails(data)
             }, [userId])

             return &lt;div&gt;...
            }
          </code></pre>
        </section>
        <section data-background="#b5533c">
            <h3>TP-02</h3>
            <h4>Shopping list</h4>
            <ol style="font-size: 34px">
                <li>Afficher le titre passé par le parent</li>
                <li>Mettre un état par défaut (liste vide)</li>
                <li>Mettre la liste des items retournée par l'appel au web service</li>
                <li>Afficher les items dans une liste &lt;ul&gt;&lt;/ul&gt;</li>
                <li>Créer un composant dédié pour chaque élément de la liste &lt;li&gt;</li>
                <li>
                    Bonus: Créer un composant qui fait l'appel ajax, et passe le résultat à un composant enfant, qui lui
                    itère
                    sur la liste.
                </li>
            </ol>
        </section>
        <section>
            <h3>Bonus TP-02</h3>
            <pre><code data-trim>
            const ShoppingList = ({title}) => {
               const [items, setItems] = useState([])
               // useEffect({...}, [])
               return &lt;ShoppingListInternal title={title}
                        items={items}/&gt;
            }
            const ShoppingListInternal = ({title, items}) =>
            &lt;div&gt;
                &lt;h2&gt;{title}&lt;/h2&gt;
                &lt;ul&gt;{items.map(item =>
                    &lt;ShoppingItem key={item.id} item={item}/&gt;)}
                &lt;/ul&gt;
            &lt;/div&gt;
            </code></pre>
        </section>
        <section>
            <h3>Passer des fonctions dans les props</h3>
            <pre><code data-trim>
            const ShoppingList = ({title}) => {
                const [items, setItems] = useState([])
                // useEffect({...}, [])

                const deleteItem = (itemIdToDelete) => {
                    setItems(prev => prev.filter(item => item.id !== itemIdToDelete)
                }
                return (&lt;ShoppingListInternal
                        title={title}
                        items={items}
                        del={deleteItem}/&gt;)
                }
            }
            </code></pre>
        </section>
        <section>
            <h3>Utiliser les fonctions des props</h3>
            <pre><code data-trim>
            const ShoppingListInternal = ({title, items, del}) => (
                &lt;div&gt;
                    &lt;h2&gt;{title}&lt;/h2&gt;
                    &lt;ul&gt;
                        {
                          items.map(item => (&lt;li onClick={() => del(item.id)}&gt;
                            {item.label}: {item.price}€ &lt;/li&gt;))
                        }
                    &lt;/ul&gt;
                &lt;/div&gt;)
            </code></pre>
        </section>
        <section>
            <h3>Récupérer l'évènement JS</h3>
            <pre><code data-trim>
            const ClickableApp = () => {
                const handleClick = e => {
                    console.log('click !', e)
                }
                return &lt;div onClick={handleClick}&gt;Click me !&lt;/div&gt;
            }
            </code></pre>
            <pre class="fragment"><code data-trim>
            const ClickableApp = () => (
              &lt;div
                onClick={e => console.log('click !', e)}&gt;
                Click me !
              &lt;/div&gt;
            )
          </code></pre>
        </section>
        <section>
            <h3>Avec du style</h3>
        </section>
        <section>
            <h3>inline style vs css</h3>

            <p>Pourquoi ne pas inliner le css dans le js ?</p>

            <pre><code data-trim>
            MyComponent = () => {
                const mystyle = {backgroundColor: '#F0ABCD'}
                return &lt;div style={mystyle}/&gt;
            }
            </code></pre>
            <p>Ou utiliser une css globale, une css par composant (css modules avec Webpack)</p>

            <pre><code data-trim>
            import './MyComponent.css'
          </code></pre>
        </section>
        <section>
            <h3>Ant Design</h3>

            <div style="font-size: 30px; text-align: left; margin-left: 50px">
                <p>React Components for desktop applications</p>
            </div>
            <pre><code data-trim>
            &lt;Button type="primary" onClick={handleClick}&gt;Go!&lt;/Button&gt;
          </code></pre>

            <div style="font-size: 30px; text-align: left; margin-left: 50px">
                <p>Documentation</p>
                <p>
                    <a target="_blank" href="https://ant.design/docs/spec/introduce">
                        https://ant.design/docs/spec/introduce
                    </a>
                </p>
            </div>
        </section>
        <section>
            <h3>Material-UI</h3>

            <div style="font-size: 30px; text-align: left; margin-left: 50px">
                <p>React components that implement Google's Material Design</p>
            </div>
            <pre><code data-trim>
                &lt;Button onClick={handleClick}&gt;Go!&lt;/Button&gt;
          </code></pre>

            <div style="font-size: 30px; text-align: left; margin-left: 50px">
                <p>Documentation</p>
                <p><a target="_blank" href="https://material-ui.com/api/button/">https://material-ui.com/api/button/</a>
                </p>
            </div>
        </section>
        <section>
            <h3>Styled-Components</h3>

            <div style="font-size: 30px; text-align: left; margin-left: 50px">
                <p>Visual primitives for the component age.</p>
            </div>
            <pre><code data-trim>
            const Title = styled.h1`
                font-size: 1.5em;
                text-align: center;
                color: palevioletred;
            `
            &lt;Title&gt;Nice title !&lt;/Title&gt;
            </code></pre>

            <div style="font-size: 30px; text-align: left; margin-left: 50px">
                <p>Documentation</p>
                <p>
                    <a target="_blank" href="https://www.styled-components.com/docs/api"
                    >https://www.styled-components.com/docs/api</a
                    >
                </p>
            </div>
        </section>
        <section>
            <h3>Tips and tricks</h3>
            <h4 class="fragment">(Workarounds)</h4>
        </section>
        <section>
            <h3>Fragments</h3>
            <pre><code data-trim>
            const ComponentWithFragment = () => (
                &lt;&gt;
                    &lt;div&gt;Les&lt;/div&gt;
                    &lt;span&gt;fragments&lt;/span&gt;
                &lt;/&gt;
            )
            </code></pre>
        </section>
        <section>
            <h3>JSX if (else)</h3>
            <p>if</p>
            <pre><code data-trim>
                {user && <div>{user.login}</div>}
            </code></pre>
            <p>not</p>
            <pre><code data-trim>
                {user || <div>No User</div>}
            </code></pre>
            <p>if-else</p>
            <pre><code data-trim>
                {user
                    ? <div>{user.login}</div>
                    : <div>No User</div>}
            </code></pre>
            <p>
                <a href="https://angular.io/api/common/NgIf" style="font-size: 0.5em">Pas mieux en angular :)</a>
            </p>
        </section>
        <section>
            <h3>Commentaires</h3>
            <pre><code data-trim>
            const MyComponent = () => {
                // comment inside JS
                return &lt;div&gt;
                    {/* Comment inside JSX */}
                &lt;/div&gt;
            }
            </code></pre>
        </section>
        <section>
            <h3>Children</h3>

            <pre><code data-trim>
            ReactDOM.render(
               &lt;ButtonApp title="My Application"&gt;Press Me! &lt;/ButtonApp&gt;,
               document.getElementById('root')
            )
            </code></pre>
            <pre><code data-trim>
            export const ButtonApp = ({title, children}) => {
                return &lt;div&gt;
                    &lt;div&gt;{title}&lt;/div&gt;
                    &lt;button&gt;{children}&lt;/button&gt;
                &lt;/div&gt;
            }
            </code></pre>
        </section>
        <section data-background="#b5533c">
            <h3>TP-03</h3>
            <h4>Liste des étudiants</h4>
            <ol>
                <li>Créer un champ "input" qui filtre les éléments de la table</li>
                <li>
                    Afficher le nom de l'étudiant sélectionné (Celui sur lequel on a cliqué), ou un message si aucun
                    étudiant
                    n'est sélectionné (par défaut)
                </li>
                <li>Bonus : Faire une Pull Request pour faire une <b>jolie</b> correction à ce TP ;)</li>
            </ol>
        </section>
        <section>
            <h3>Ce qu'on a vu jusque là</h3>
            <ul>
                <li>Un composant a des props et des états (states)</li>
                <li>Un composant sans états est plus simple à écrire (et donc plus maintenable)</li>
            </ul>
        </section>
        <section>
            <h3>Flux & Redux</h3>
        </section>
        <section>
            <h3>Flux</h3>
            <div style="font-size: 30px; text-align: left; margin-left: 15px">
                <ul>
                    <li>Store: Stocker la donnée</li>
                    <li>Action: Mettre à jour le model</li>
                    <li>Dispatcher: Aiguiller les actions dans les stores</li>
                    <li>View: Composants UI</li>
                </ul>
            </div>
            <img data-src="images/flux.png" alt="flux"/>

            <p>Le flux est <i>unidirectionel</i> ! (<strike>2-way binding</strike>)</p>
        </section>
        <section>
            <h3>Bad Practice vs. Good Practice</h3>

            <img data-src="images/flux-bestpractice.png" alt="best practices" height="300"/>
            <div style="font-size: 30px; text-align: left; margin-left: 15px">
                <ul>
                    <li>On ne met pas à jour les composants directement</li>
                    <li>On peut utiliser le store (redux), les stores (flux), les services (RxJs Subjects ), ...</li>
                </ul>
            </div>
        </section>
        <section>
            <h3>Redux</h3>
        </section>
        <section>
            <h3>Actions</h3>
            <pre><code data-trim>
                {type: 'INCREMENT', inc: 3}
                {type: 'ADD_TODO', text: 'Buy bread'}
                {type: 'SET_USER', user: new User(1, 'toto')}
            </code></pre>

            <h3>Action Creator</h3>
            <pre><code data-trim>
            export const incrementor = (inc) => {
                return {type: 'INCREMENT', inc}
            }
            </code></pre>
            <pre><code data-trim>
            export const incrementor =
                (inc) => ({type: 'INCREMENT', inc})
            </code></pre>
        </section>
        <section>
            <h3>Redux</h3>
            <pre><code data-trim>
                const userId = window.current_account.id
            </code></pre>
            <p>&laquo; Pourquoi utiliser Redux alors qu'on a déjà les variables globales ? &raquo;</p>
            <p class="fragment">#TROLL</p>
        </section>
        <section>
            <h3>Redux</h3>

            <div style="font-size: 30px; text-align: left; margin-left: 15px">
                <ul>
                    <li>Store unique (plus simple pour l'isomorphisme / SSR)</li>
                    <li>Le <b>state</b> du store est read-only</li>
                    <li>On dispatch des <b>actions</b> pour mettre à jour le state (du store)</li>
                    <li class="fragment">Les <b>actions</b> sont envoyées aux <b>reducers</b></li>
                    <li class="fragment">Les <b>reducers</b> sont des fonctions <b>pures</b></li>
                    <li class="fragment">Les <b>Reducers</b> prennent un état et une action en paramètre</li>
                    <li class="fragment">et retournent un nouvel état dans un objet 'immutable'</li>
                </ul>
            </div>
            <img data-src="images/redux.png" alt="redux" height="200"/>
        </section>
        <section>
            <h3>Reducer</h3>
            <pre><code data-trim>
            export const display = (state = 0, action) => {
                switch (action.type) {
                    case 'INCREMENT':
                        return state + action.inc
                    case 'DECREMENT':
                        return state - action.inc
                    default:
                        return state
                }
            }
            </code></pre>
            Le <b>state</b> est read-only !
            <img data-src="images/redux.png" alt="redux"/>
        </section>
        <section>
            <h3>React & Redux</h3>
        </section>
        <section>
            <h3>Composition de Reducers</h3>
            <h4>Approche naïve</h4>
            <pre><code data-trim>
            const initialState = {user: '', counter: 0}
            export const myGlobalReducer =
                (state = initialState, action) => {
                    switch (action.type) {
                        case 'SET_USER':
                           return {...state, user: action.user}
                        case 'INCREMENT':
                           return {...state, counter: state.counter + 1}
                        case 'DECREMENT':
                           return {...state, counter: state.counter - 1}
                        default:
                           return state
                }
            }
            </code></pre>
            Pas vraiment lisible pour des applications moyennes ou grosses...!
        </section>
        <section>
            <h3>Composition de reducers</h3>
            <pre><code data-trim>
            export const user =
                (state = null, action) => {
                    switch (action.type) {
                        case 'SET_USER':
                            return action.user
                        default:
                            return state
                    }
                }
            export const counter =
                (state = 0, action) => {
                    switch (action.type) {
                        case 'INCREMENT':
                            return state + 1
                        case 'DECREMENT':
                            return state - 1
                        default:
                            return state
                    }
            }
            </code></pre>
        </section>
        <section>
            <h3>Composition de reducers</h3>
            <h4>Effet Wahou</h4>
            <pre><code data-trim>
            const init = {user: 'nobody', counter: 0}
            export const myGlobalReducer = (state = init, action) =>
              ({
                user: user(state.user, action),
                counter: counter(state.counter, action)
              })
            </code></pre>
            <p>Et avec un peu de magie...</p>
            <pre><code data-trim>
            import { combineReducers } from 'redux'
            export const myGlobalReducer = combineReducers({
                user,
                counter
            })
            </code></pre>
        </section>
        <section>
            <h3>Rappels</h3>
            <div style="font-size: 30px; text-align: left; margin-left: 85px">
                <ul>
                    <li>Actions</li>
                    <li>Reducers</li>
                    <li>Store</li>
                    <li>Composants React</li>
                    <li>Maintenant il fault lier les composants au store</li>
                </ul>
            </div>
            <img data-src="images/redux.png" alt="redux"/>
        </section>
        <section>
            <h3>Les Hooks redux</h3>
            <ul>
                <li>Séparation des responsabilités: UI vs tuyauterie</li>
                <li>Le code technique est fait dans les hooks</li>
            </ul>
        </section>
        <section>
            <h3>Hooks</h3>

            <p style="font-size: 28px">useSelector</p>
            <pre><code data-trim>
            import { useSelector } from 'react-redux'

            export const MyComponent = () => {
              const foo = useSelector(state => state.foo)
              return &lt;div&gt;{foo.id} / {foo.info} &lt;/div&gt;
            }
            </code></pre>
            <p style="font-size: 28px">useDispatch</p>
            <pre><code data-trim>
            import { useDispatch } from 'react-redux'

            export const MyComponent = () => {
              const dispatch = useDispatch()
              return &lt;div onClick={() => dispatch({type: 'INC', inc: 1})}&gt;
                Click !
              &lt;/div&gt;
            }
            </code></pre>
        </section>
        <section>
            <h3>Connected component</h3>
            <pre><code data-trim>
            export const SelectPostalCode = () => {
              const dispatch = useDispatch()
              const currentPc = useSelector(state => state.currentPc)
              const postalCodes = useSelector(state => state.postalCodes)

              const handleOnChange = e => {
                const action = setCurrentPc(e.target.value)
                dispatch(action)
              }
              &lt;select onChange={handleOnChange} value={currentPc}&gt;
              {
                postalCodes.map(pc =>
                    &lt;option key={pc} value={pc}&gt;{pc}&lt;/option&gt; )
              }
            &lt;/select&gt;
            )
          </code></pre>
        </section>
        <section>
            <h3>Passer le store à l'application</h3>

            <p>Tous les composants "redux" de l'application doivent avoir accès au store.</p>
            <pre><code data-trim>
                import ReactDOM from 'react-dom'
                import {Provider} from 'react-redux'
                import {createStore} from 'redux'
                import {reducer} from './reducers/index'
                import {App} from './components/app'

                const store = createStore(reducer)

                ReactDOM.render(
                    &lt;Provider store={store}&gt;
                        &lt;App/&gt;
                    &lt;/Provider&gt;,
                    document.getElementById('app')
                )
          </code></pre>
        </section>
        <section data-background="#b5533c">
            <h3>TP-04</h3>
            <h4>Shopping list - bis</h4>
            <ol style="font-size: 34px">
                <li>Installer redux-dev-tools</li>
                <li>
                    Comme le TP-02, mais utiliser le <i>state</i> du store plutot que le <i>state</i> du composant, et
                    initialiser la liste (avec un morceau de code synchrone).
                </li>
                <li>Creer un <i>action creator</i> <b>setItems</b> qui retourne une <b>ItemAction</b></li>
                <li>Créer un reducer <b>items</b> qui prend une <b>ItemAction</b> en entrée</li>
                <li>Créer un global reducer grâce à <b>combineReducer</b></li>
                <li>Lier le composant au <i>store</i></li>
                <li>Bonus: Créer un boutton qui ajoute un nouvel item à la liste</li>
            </ol>
        </section>
        <section>
            <h3>Actions asynchrones</h3>
        </section>
        <section>
            <h3>Jusque là</h3>
            <ul>
                <li>Redux permet de ne dispatcher que des objets (les actions)</li>
                <li class="fragment">
                    <b>redux-thunk</b>, <b>redux-saga</b>, <b>mobx</b> permettent de dispacher des fonctions, et donc
                    des
                    actions asynchrones ou des actions avec des conditions. Ces librairies sont des <i>middlewares</i>.
                </li>
            </ul>
        </section>
        <section>
            <h3>redux-thunk</h3>
        </section>
        <section>
            <h3>Configuration</h3>
            <pre><code data-trim>
                import {reducer} from './reducers/index'
                import {createStore, applyMiddleware} from 'redux'
                import thunk from 'redux-thunk'

                const store = createStore(
                reducer,
                applyMiddleware(thunk)
                )

                </code></pre>
        </section>
        <section>
            <h3>ThunkActionCreator</h3>
            <pre><code data-trim>
            function incrementCreator(inc) {
                return {
                    type: 'INCREMENT_COUNTER',
                    inc: inc
                }
            }

            function incrementAsyncCreator(inc) {
                return dispatch => setTimeout(
                        () => dispatch(incrementCreator(inc)),
                        1000)
            }
            </code></pre>
        </section>
        <section>
            <h3>Pour résumer</h3>

            <p>
                Une <i>ThunkAction</i> est une fonction qui prend <i>dispatch()</i> and <i>getState()</i> comme
                paramètres,
                et qui retourne le résultat de l'appel à <i>dispatch()</i>.
            </p>
        </section>
        <section>
            <h3>Example</h3>
            <pre><code data-trim>
            const getItems =
                (userId) => axios.get('users/' + userId + '/items')
                    .then(resp => resp.data)
                    .catch(error => console.log(error.toString()))
            </code></pre>
            <pre class="fragment"><code data-trim>
            export const fetchItems = () =>
              (dispatch, getState) => getItems(getState().userId)
              .then(items => dispatch({type: 'SET_ITEMS', items: items}))
            .catch((error) => console.log(error))
            </code></pre>
            <pre class="fragment"><code data-trim>
            export const UserItems = () => {
              const dispatch = useDispatch()

              handleClick = () => {
                const action = fetchItems()
                dispatch(action)
              }

              return ...
            }

            </code></pre>
        </section>
        <section data-background="#b5533c">
            <h3>TP-05</h3>
            <h4>Shopping list - ter</h4>
            <ol>
                <li>Configurer le "thunk" Middleware dans index.js</li>
                <li>Comme le TP-04 mais avec un appel asynchrone (http) pour charger la liste des items</li>
                <li>Bonus: Créer une action qui applique un taux de TVA, lorsque l'on ajoute un nouvel élément</li>
            </ol>
        </section>
        <section>
            <h3>Bravo !</h3>
            <p>C'était la partie la plus compliquée !</p>
            <p>On sait créer des composants et leur passer des données</p>
            <ul>
                <li>Depuis le composant parent</li>
                <li>Depuis le <i>LocalState</i></li>
                <li>Depuis le <b>store</b></li>
                <li>Depuis un grand(n)-parent grâce au context...</li>
            </ul>
        </section>
        <section>
            <h3>Context</h3>
        </section>
        <section>
            <h3>Context API</h3>
            <ul>
                <li>On peut passer des données aux composants enfant (partout dans la hiérarchie).</li>
                <li class="fragment">
                    Beaucoup de librairires sont basées la dessus. Ce n'était pas une API officielle avant Mars 2018.
                </li>
                <li class="fragment">
                    <i>react-redux</i> fonctionne grâce à ça, le store est passé à tous les composants.
                </li>
            </ul>
        </section>
        <section>
            <h3>Context API</h3>
            <p>Créer un <i>Context</i>, et encapsuler l'application à l'interieur du <i>&lt;Context.Provider&gt;</i></p>
            <pre><code data-trim>
                const Context = React.createContext()
                export default Context
            </code></pre>
            <pre><code data-trim>
                ...
                return &lt;Context.Provider
                            value={{color: 'purple', user: new User(1, 'admin')}}&gt;
                    &lt;App/&gt;
                &lt;/Context.Provider&gt;
            </code></pre>
        </section>
        <section>
            <h3>Context API</h3>
            <p>Ensuite on récupère le <i>context</i> là ou l'on veut l'utiliser avec le hook <i>useContext()</i></p>
            <pre><code data-trim>
            import {useContext} from 'react'
            import MyContext from './Context'

            const MyComponent = () => {
                const ctx = useContext(MyContext)
                return &lt;div style={{backgroundColor: ctx.color}}&gt;
                   Some text
                &lt;/div&gt;
              }
            }
            </code></pre>
        </section>
        <section data-background="#b5533c">
            <h3>TP-06</h3>
            <h4>Context API</h4>
            <p>L'objectif et de passer une couleur et un utilisateur d'un composant parent à un composant
                'petit-fils'</p>
            <ol>
                <li>Encapsuer un composant React (Large) dans un Context, avec un User et une couleur.</li>
                <li>Afficher les données du <i>context</i> dans un composant (petit-)enfant (Small)</li>
            </ol>
        </section>
        <section>
            <h3>Tests</h3>
        </section>
        <section>
            <h3>Jest, Enzyme, React Test Renderer, React Testing Library, ...</h3>
            <p>L'idées est de tester les <i>composants</i>, avec leurs états et leurs props.</p>
            <p>L'arrivée des hooks a fait bouger la hiérarchie des outils de test.</p>
            <ul>
                <li>Enzyme: les Hooks ont mis un moment à être supportés</li>
                <li>React test renderer: Pas de façon simple de tester les évènements</li>
                <li>React testing library: Des nouveaux paradigmes sur la façon de tester</li>
            </ul>
        </section>
        <section>
            <h3>Faire le rendu d'un composant</h3>

            <pre><code data-trim>
            import { render } from '@testing-library/react'

            describe('MyComponent', () => {
                it('should work !', () => {
                    render(&lt;MyComponent/&gt;)
                })
            })
            </code></pre>
            <p>
                <a href="https://testing-library.com/docs/react-testing-library/api#render" target="_blank"
                >React Testing Library</a
                >
            </p>
        </section>
        <section>
            <h3>Tester le rendu d'un composant et ses sous-composants, avec les snapshots</h3>
            <pre><code data-trim>
            import { render } from '@testing-library/react'

            it('renders App and its sub components', () => {
                const { container } = render(&lt;App /&gt;)

                expect(container).toMatchSnapshot()
            })
            </code></pre>
        </section>
        <section>
            <h3>Assertions Jest</h3>
            <pre><code data-trim>
            it('tests', () => {
                expect(1 + 1).toEqual(2)
                expect(['a', 'b']).toHaveLength(2)
                expect(0 / 2).not.toBeNaN()
            })
            </code></pre>
            <p>.toEqual(value), .toBeNull(), .toBeTruthy(), .toHaveLength(number), .not.toBeNaN(), ...</p>
            <p><a href="https://jestjs.io/docs/en/expect" target="_blank">Jest</a></p>
        </section>
        <section>
            <h3>Tester le rendu avec des sélecteurs</h3>
            <pre><code data-trim>
            it('should display user infos and winner', () => {
                // Given
                const { container } = render(&lt;Podium first={player4}
                                                     second={player16}
                                                     third={player2} /&gt;)
                const playerInfos = container.querySelector('.infos')
                const winner = container.querySelector('#winner')

                // Then
                expect(playerInfos).toHaveLength(3)
                expect(winner.textContent).toMatch('player4')
            })
            </code></pre>
        </section>
        <section>
            <h3>Rechercher des éléments avec les Queries RTL</h3>
            </code></pre>
            <pre><code data-trim>
          import {render, screen} from '@testing-library/react'

          it('renders Alarm', () => {
            render(&lt;App/&gt;)
            expect(screen.getByText('Menu Alarme')).toBeTruthy()
            expect(screen.getAllByTestId('alarme')).toHaveLength(2)
            expect(screen.getAllByRole('button')).toHaveLength(2)
          })
          </code></pre>
        </section>
        <section>
            <h3>Vérifier qu'une méthode a été appelée</h3>
            <pre><code data-trim>
            const mockFunction = jest.fn()
            expect(mockFunction).toHaveBeenCalledWith(42)
          </code></pre>
        </section>
        <section>
            <h3>Simuler des événements</h3>
            <pre><code data-trim>
          import {render, fireEvent, screen } from '@testing-library/react'

          it('fires events', () => {
            render(&lt;NiceInput /&gt;)
            const input = screen.getByRole('input')

            fireEvent.change(input, {target: {value: 'new text'}})
          })
          </code></pre>
        </section>
        <section>
            <h3>Async testing</h3>
            <pre><code data-trim>
          import { render, screen } from '@testing-library/react'

           it('loads data on creation', async () => {
            render(&lt;UserInfo id={42} /&gt;)
            await screen.getByText('Jennifer')

            // expect(...)
          })
          </code></pre>
        </section>
        <section>
            <h3>Mocking avancé avec Jest - functions</h3>
            <pre><code data-trim>
            import { render, screen } from '@testing-library/react'

            jest.mock('api/users', () => ({
              fetchUser: userId =>
                Promise.resolve(new User(userId, 'Jennifer')),
            }))
            describe('UserInfo Component', async () => {
              it('should display user ', () => {
                render(&lt;UserInfo id={42} /&gt;)
                await screen.getByText('Jennifer')

                // expect...
              }
            })
            </code></pre>
        </section>
        <section>
            <h3>Run tests</h3>
            <ul>
                <li><i>npm test</i> in command line</li>
                <li><i>--coverage</i> for test coverage</li>
                <li><i>jest runner</i> in Webstorm / IntelliJ</li>
            </ul>
            <aside class="notes">
                File > Settings > JavaScript > Libraries et Download Jest Typescript definition pour ne plus avoir
                d'erreurs
                sur 'describe' dans les sources.
            </aside>
        </section>
        <section data-background="#b5533c">
            <h3>TP-07</h3>
            <h4>Tests</h4>
            <p>L'objectif est d'écrire les tests du TP-03</p>
            <p></p>
            <ol style="font-size: 32px">
                <li>Créer un fichier .test.js pour chaque composant</li>
                <li><i>StudentDetails</i>: Vérifier les textes (avec Student null ou non)</li>
                <li><i>Filter</i>: Verifier que le callback est appelé quand l'évènement <i>change</i> est propagé</li>
                <li>
                    <i>StudenstTable</i>: Vérifier le nombre de ligne dans le tableau, suivant le jeu de données. Tester
                    les
                    appels aux callbacks aussi.
                </li>
                <li>
                    <i>StudentsApp</i>: Vérifier que les composants sont toujours affichés de la même façon (avec un
                    snapshot)
                    . Tester que <i>filteredStudents()</i> retourne une liste filtrée.
                </li>
            </ol>
        </section>
        <section>
            <h3>Routing</h3>
        </section>
        <section>
            <h3>react-router</h3>

            <p>Il y a différents Routers pour gérer l'historique de la navigation et des URLs:</p>
            <ul>
                <li><b>BrowserRouter</b> : /monsite/page1/partie2</li>
                <li><b>HashRouter</b>: /monsite/#/page1/partie2</li>
                <li><b>MemoryRouter</b> : /</li>
            </ul>
            <p style="font-size: 24px">
                Pour le BrowserRouter il faut rediriger toutes les requêtes vers index.html, sauf les .css, .js, et les
                appels aux webservices.
            </p>
        </section>
        <section>
            <h3>react-router</h3>

            <p>Il faut définir le routeur à la racine de l'application.</p>
            <pre><code data-trim>
            import {BrowserRouter as Router,
                Route} from 'react-router-dom'

            ReactDOM.render(
              &lt;Router&gt;
                  &lt;Route exact path="/" component={Home} /&gt;
                  &lt;Route path="/about" render={() => <h2>About...</h2>} /&gt;
                  &lt;Route path="/admin" component={Admin} /&gt;
              &lt;/Router&gt;,
              document.getElementById('root')
            )
            </code></pre>
        </section>
        <section>
            <h3>Nested routes !</h3>
            <pre><code data-trim>
            const Admin = () => (
            &lt;div&gt;
              &lt;h2&gt;Administration&lt;/h2&gt;
              &lt;Route path={'/admin/users'} component={UsersAdmin}/&gt;
              &lt;Route path={'/admin/articles'} component={ArticlesAdmin}/&gt;
            &lt;/div&gt;
            )
            </code></pre>
        </section>
        <section>
            <h3>react-router</h3>
            <p>
                Il est possible de générer les liens automatiquement (voir la documentation)
                <a target="_blank" href="https://reacttraining.com/react-router/web/api/NavLink">doc</a> pour l'API
            </p>
            <pre><code data-trim>
            &lt;Link to="/admin/users"&gt;Administration des utilisateurs&lt;/Link&gt;
            </code></pre>
        </section>
        <section>
            <h3>react-router</h3>
            <p>Dynamic urls</p>
            <pre><code data-trim>
            &lt;Route path={'/admin/users/:userId'} component={UserAdmin}/&gt;
            </code></pre>
            <pre><code data-trim>
            const UserAdmin = ({match}) => (
            &lt;div&gt;
                Manage user {match.params.userId}
            &lt;/div&gt;
            )
            </code></pre>
        </section>
        <section>
            <h3>match</h3>
            <p>match contient plusieurs données :</p>
            <ul>
                <li><b>params</b>: clé-valeurs des paramètres dans l'url (ex: /user/:id)</li>
                <li><b>url</b>: l'url qui a matché</li>
                <li><b>isExact</b>: true si l'url a matché de façon exacte (non partielle)</li>
                <li><b>path</b>: pattern du match</li>
            </ul>
            <pre><code data-trim>
            const Admin = ({match}) => (
                &lt;Link to={`${match.url}/users`}&gt;
                    Users
                &lt;/Link&gt;
                &lt;Link to={`${match.url}/articles`}&gt;
                    Articles
                &lt;/Link&gt;
            )
            </code></pre>
        </section>
        <section data-background="#b5533c">
            <h3>TP-08</h3>
            <h4>React-router</h4>
            <p>L'objectif est de construire une application avec 3 "pages"</p>
            <p>Une de ces pages aura un id dans les paramètres d'URL</p>
            <ol>
                <li>Créer les liens vers /about et /users</li>
                <li>Créer les routes pour /about et /users</li>
                <li>Créer les liens vers /users/elsa et /users/anna</li>
                <li>Créer la route pour le composant UserDetail</li>
                <li>Ecrire le lien pour les images de profil (elsa.jpeg and anna.jpeg)</li>
            </ol>
        </section>
        <section>
            <h3>Optimisations</h3>
        </section>
        <section>
            <h3>Ne pas faire trop de ré-affichages innutiles</h3>
            <img data-src="images/should-component-update.png" alt="update"/>
        </section>
        <section>
            <h3>Reconciliation</h3>
            <p>
                Le <b>Virtual DOM</b> est...
                <span class="fragment" style="font-size: 24px">
              Une représentation mémoire des composants. Quand le rendu d'un composant est fait à nouveau, le nouveau
              V-DOM est comparé à l'ancien V-DOM. Si il y a une différence, le DOM du browser est (partiellement) mis à
              jour.
            </span>
            </p>
        </section>
        <section>
            <h3>Trop de 're-rendering'</h3>
            <ul>
                <li>Memoization</li>
                <li>useCallback()</li>
                <li>useMemo()</li>
            </ul>
        </section>
        <section data-auto-animate data-visibility="hidden">
            <h3 data-id="memo">Perfs - React.memo</h3>
            <p data-id="memo-p">React.memo permet de <em>memoize</em> un composant React.</p>
            <pre data-id="memo-pre"><code data-trim>
           const MyComponent = () => ...
           export default React.memo(MyComponent)
          </code></pre>
        </section>
        <section data-auto-animate>
            <h3 data-id="memo">Perfs - React.memo</h3>
            <p data-id="memo-p">React.memo permet de <em>memoize</em> un composant React.</p>
            <pre data-id="memo-pre"><code data-trim>
           const MyComponent = () => ...
           export default React.memo(MyComponent, (prevProps, nextProps) => {
            return prevProps.user?.id === nextProps.user?.id
           })
          </code></pre>
        </section>
        <section data-auto-animate data-visibility="hidden">
            <h3 data-id="callback">Perfs - useCallback</h3>
            <p data-id="callback-p">
                useCallback permet de ne pas recréer une nouvelle fonction à chaque exécution (re-render) d'un composant.
                Ces fonctions sont destinées à être passées comme callback aux composants enfants.
            </p>
            <pre data-id="callback-pre"><code data-trim>
           const MyComponent = () => (
            &lt;Button onClick={e => console.log(e)}&gt;Click me&lt;/&gt;
           )
          </code></pre>
        </section>
        <section data-auto-animate data-visibility="hidden">
            <h3 data-id="callback">Perfs - useCallback</h3>
            <p data-id="callback-p">
                useCallback permet de ne pas recréer une nouvelle fonction à chaque exécution (re-render) d'un composant.
                Ces fonctions sont destinées à être passées comme callback aux composants enfants.
            </p>
            <pre data-id="callback-pre"><code data-trim>
           const MyComponent = () => {
            const handleClick = e => console.log(e)

            return &lt;Button onClick={handleClick}&gt;Click me&lt;/&gt;
           })
          </code></pre>
        </section>
        <section data-auto-animate>
            <h3 data-id="callback">Perfs - useCallback</h3>
            <p data-id="callback-p">
                useCallback permet de ne pas recréer une nouvelle fonction à chaque exécution (re-render) d'un composant.
                Ces fonctions sont destinées à être passées comme callback aux composants enfants.
            </p>
            <pre data-id="callback-pre"><code data-trim>
           const MyComponent = () => {
            const handleClick = useCallback(e => console.log(e), [])

            return &lt;Button onClick={handleClick}&gt;Click me&lt;/&gt;
           })
          </code></pre>
        </section>
        <section data-background="#b5533c">
            <h3>TP-09</h3>
            <h4>Optimisations</h4>
            <ul>
                <li>
                    Utiliser la memoization sur le composant Calculator pour éviter le long calcul
                </li>
                <li>
                    Utiliser useCallback pour éviter au composant Button de se réafficher
                </li>
            </ul>
        </section>
        <section>
            <h3>Let's do it !</h3>
            <h3>help ? <a href="mailto:jbcazaux@gmail.com">jbcazaux@gmail.com</a></h3>
            <h3><a href="https://formation-reactjs.fr">https://formation-reactjs.fr</a></h3>
        </section>
    </div>
</div>

<script src="reveal/reveal.js"></script>
<script src="reveal/plugin/zoom/zoom.js"></script>
<script src="reveal/plugin/notes/notes.js"></script>
<script src="reveal/plugin/search/search.js"></script>
<script src="reveal/plugin/markdown/markdown.js"></script>
<script src="reveal/plugin/highlight/highlight.js"></script>
<script>
  console.log('showHiddenSlides', !window.location.search.match(/print-pdf/gi))
  Reveal.initialize({
    controls: true,
    progress: true,
    center: true,
    hash: true,
    showHiddenSlides: !window.location.search.match(/print-pdf/gi),
    pdfSeparateFragments: false,
    plugins: [RevealZoom, RevealNotes, RevealSearch, RevealMarkdown, RevealHighlight],
  })
</script>
</body>
</html>
