<!DOCTYPE html>
<html>
  <head>
    <meta name="ROBOTS" content="INDEX, FOLLOW" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="description" content="Formation React js, avec ES6" />
    <meta
      name="keywords"
      content="formation react, formation reactjs, freelance, flux, redux, es6, props, state, jsx"
    />
    <link rel="canonical" href="https://formation-reactjs.fr" />
    <title>Formation reactjs x typescript</title>

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

    <link rel="stylesheet" href="reveal/reset.css" />
    <link rel="stylesheet" href="reveal/reveal.css" />
    <link rel="stylesheet" href="reveal/theme/sky.css" id="theme" />

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="reveal/plugin/highlight/monokai.css" id="highlight-theme" />

    <style type="text/css">
      p {
        text-align: left;
      }

      .reveal h3,
      .reveal h4 {
        text-transform: none;
      }

      .reveal pre code {
        max-height: 530px;
      }
    </style>
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <section>
          <h1>
            <img
              width="105px"
              height="auto"
              data-src="images/react.svg"
              alt="react"
              style="border: none; background: none; box-shadow: none; margin: 0"
            />React
          </h1>
          <h3>#Typescript</h3>
          <p style="text-align: center"><a target="_blank" href="http://twitter.com/jbcazaux">@jbcazaux</a></p>

          <a href="https://www.netlify.com">
            <img
              src="https://www.netlify.com/img/global/badges/netlify-color-bg.svg"
              alt="Deploys by Netlify"
              style="border: none; background: none; box-shadow: none; margin: 0; float: right"
            />
          </a>
        </section>
        <section data-visibility="hidden"><img data-src="images/mynameis.jpg" alt="my name is" /></section>
        <section data-visibility="hidden"><img data-src="images/coffee.gif" alt="coffee break" /></section>
        <section data-visibility="hidden">
          <h3>Objectifs</h3>
          <img data-src="images/postits.jpg" alt="goals" />
        </section>
        <section>
          <h3>Versions</h3>
          <pre>
              <code data-trim>
                  "react": "18.2.0"
                  "typescript": "4.8.4"
          </code>
          </pre>
        </section>
        <section>
          <h3>Le programme !</h3>
          <ul>
            <li>
              Typescript avancé
              <ul>
                <li>Typescript</li>
                <li>Programmation fonctionnelle</li>
              </ul>
            </li>
            <li>
              ReactJS
              <ul>
                <li>Principes de base</li>
                <li>Composants</li>
                <li>Gestion de la donnée</li>
                <li>Redux</li>
                <li>Tests</li>
                <li>Routing</li>
                <li>Optimisations</li>
              </ul>
            </li>
          </ul>
        </section>
        <section>
          <h2>Typescript</h2>
        </section>
        <section>
          <h3>let, const</h3>
          <pre><code data-trim>
                let foo = 'bar'
                const MAX = 10
                const ttc = addTva(100, 20)
                </code></pre>
          <p class="fragment">
            <span style="color: #8cd0d3">let</span> vs. <span style="color: #cc9393">const</span> ?
            <span class="fragment">0-5 let / application</span>
          </p>
        </section>
        <section>
          <h3>let, const</h3>
          <pre><code data-trim>
                const user = {}
                user.name = 'john' // (1)
                user = {name: 'lea'} // (2)
                </code></pre>
          <pre class="fragment fade-up"><code data-trim>
                const arr = ['a']
                arr.push('b') // (3)
                arr = ['a', 'b'] // (4)
                </code></pre>
        </section>
        <section>
          <h3>Arrow functions</h3>
          <pre><code data-trim>
                function addOldSchool(a: number, b: number): number {
                    return a + b
                }
            </code></pre>
          <pre class="fragment"><code data-trim>
                const add = (a:number, b: number): number => {
                    return a + b
                }
                </code></pre>
          <pre class="fragment"><code data-trim>
                const add = (a:number, b: number): number => a + b
                </code></pre>
        </section>
        <section>
          <h3>Arrow functions</h3>
          <pre><code data-trim>
                const squares = [0, 1, 2, 3, 4].map(x => x * x)
                console.log(squares)
                </code></pre>
        </section>
        <section>
          <h3>Spread operator</h3>
          <pre><code data-trim>
              const user = {
                  firstname: 'john',
                  nickname: 'ninja',
                  lastname: 'doe',
                  age: 21
              }

              const updatedUser = {...user, firstname: 'toto'}
              console.log(updatedUser) // ?
            </code></pre>
        </section>
        <section data-auto-animate data-visibility="hidden">
          <h3 data-id="code-title">Spread operator</h3>
          <pre data-id="code-animation"><code class="hljs" data-trim>
                const odd = [1, 3, 5, 7, 9]
                const even = [2, 4, 6, 8]
                const all = [0]

                // arr.push([element1[, ...[, elementN]]])
                all.push(odd)
                all.push(even)

                console.log(all) // ?
                </code></pre>
        </section>
        <section data-auto-animate data-visibility="hidden">
          <h3 data-id="code-title">Spread operator</h3>
          <pre data-id="code-animation"><code class="hljs" data-trim>
                const odd = [1, 3, 5, 7, 9]
                const even = [2, 4, 6, 8]
                const all = [0]

                // arr.push([element1[, ...[, elementN]]])
                for (let i = 0; i < odd.length; i++) {
                    all.push(odd[i])
                }
                for (let i = 0; i < even.length; i++) {
                    all.push(even[i])
                }
                console.log(all) // ?
                </code></pre>
        </section>
        <section data-auto-animate>
          <h3 data-id="code-title">Spread operator</h3>
          <pre data-id="code-animation">
                <code class="hljs" data-trim>
                const odd: ReadonlyArray&lt;number&gt; = [1, 3, 5, 7, 9]
                const even: ReadonlyArray&lt;number&gt; = [2, 4, 6, 8]
                const all: ReadonlyArray&lt;number&gt; = [0, ...odd, ...even]
                </code>
            </pre>
        </section>
        <section data-visibility="hidden">
          <h3>Immutabilité !</h3>
          <p>Ne mutez pas pendant la formation, s'il vous plaît.</p>
        </section>
        <section data-auto-animate data-visibility="hidden">
          <h3>Éviter les mutations</h3>
          <pre data-id="immutability">
                <code class="hljs" data-trim>
                const defaultValues = [{money: 100}, {level: 0}]
                const defaultLevel = defaultValues[1]

                const newPlayer = {name: 'player1', data: defaultLevel}
                newPlayer.data.level = 2

                const newPlayer2 = {name: 'player2', data: defaultLevel}
                console.log(newPlayer2) // ?
          </code></pre>
        </section>
        <section data-auto-animate data-visibility="hidden">
          <h3>Éviter les mutations</h3>
          <pre data-id="immutability">
                <code class="hljs" data-trim>
               const defaultValues = [{money: 100}, {level: 0}]
               const defaultLevel = defaultValues[1]

               const newPlayer = {name: 'player1', data: defaultLevel}
               const newPlayerUpdated = {...newPlayer, data: {level : 2}}
          </code></pre>
        </section>
        <section>
          <h3>Destructuring</h3>
          <pre><code data-trim>
                const foo = {a: 1, b: 2, c: 'bar'}
                const {a} = foo
                console.log(a) // ?
          </code></pre>
        </section>
        <section>
          <h3>Destructuring</h3>
          <pre><code data-trim>
            const user: User = {
                firstname: 'john',
                nickname: 'ninja',
                lastname: 'doe',
                age: 21
            }

            function getUserName(user: User) {
                return `${user.firstname} ${user.lastname}`
            }
            console.log(getUserName(user))
            </code></pre>
          <pre class="fragment"><code data-trim>
            function getUserName({firstname, lastname}: User) {
                return `${firstname} ${lastname}`
            }
            </code></pre>
          <pre class="fragment"><code data-trim>
            const getUserName = ({firstname, lastname}: User) =>
                `${firstname} ${lastname}`
            </code></pre>
        </section>
        <section>
          <h3>Destructuring - nested</h3>
          <pre><code data-trim>
            const user: User = {
                firstname: 'john',
                lastname: 'doe',
                address: {
                    street: 'avenue des champs élysées',
                    num: '12'
                }
            }

            function getUserAddress(user: User) {
             return `${user.address.num} ${user.address.street}`
            }
            </code></pre>
          <pre class="fragment"><code data-trim>
            const getUserAddress = ({address: {num, street}}: User) =>
                `${num} ${street}`
            </code></pre>
        </section>
        <section>
          <h3>Destructuring - alias</h3>
          <pre><code data-trim>
            const user: User = {
                firstname: 'john',
                lastname: 'doe',
                address: {
                    street: 'avenue des champs élysées',
                    num: '12'
                }
            }

            const getUserAddress = ({address: {num: foo, street: bar}}: User) =>
                `${foo} ${bar}`
            </code></pre>
        </section>
        <section>
          <h3>Destructuring - arrays</h3>
          <pre><code data-trim>
            const maths = [x => x + 1, x => x * x, x => x * x * x]
            const [plus1, square] = maths
            plus1(41) // 42
            square(12) // 144
            </code></pre>
        </section>
        <section>
          <h3>Shorthand Notation</h3>
          <pre><code data-trim>
                const foo = 42
                const bar = 1

                const longer = {
                    foo: foo,
                    bar: bar
                }
            </code></pre>
          <pre class="fragment"><code data-trim>
                const shorter = {
                    foo,
                    bar
                }
            </code></pre>
        </section>
        <section>
          <h3>Promesses VS. async - await</h3>
          <pre><code data-trim>
            axios.get('/users/42/items')
                .then(resp => resp.data)
                .then(items => items.map(item => item.id))
                .then(ids => {/* use the ids */})
                .catch(error => console.log(error.toString()))
            </code></pre>
          <pre class="fragment"><code data-trim>
            const fetchItems = async () => {
                try {
                    const response = await axios.get('/users/42/items')
                    const items = response.data
                    const itemIds = items.map(item => item.id))
                    /* use the ids */
                } catch(error){
                    console.log(error.toString())
                }
            }
            </code></pre>
        </section>
        <section>
          <h3>Promesses VS. async - await</h3>
          <pre><code data-trim>
            axios.get('/users/42/items')
                .then(({data : items}) => items.map(item => item.id))
                .then(ids => {/* use the ids */})
                .catch(error => console.log(error.toString()))
            </code></pre>
          <pre><code data-trim>
            const fetchItems = async () => {
              try {
                const {data: items} = await axios.get('/users/42/items')
                const itemIds = items.map(item => item.id))
                /* use the ids */
              } catch(error){
                console.log(error.toString())
              }
            }
            </code></pre>
        </section>
        <section>
          <h3>Rappels - currying</h3>
          <pre><code data-trim>
            const add = function(x) {
                return function(y) {
                    return x + y
                }
            }
            add(2)(3) // ???
          </code></pre>
          <pre class="fragment"><code data-trim>
                const add2 = add(2)
                add2(3) // = ?
            </code></pre>
          <pre class="fragment"><code data-trim>
                const add = x => y => x + y // WTF ?!
            </code></pre>
          <pre class="fragment"><code data-trim>
                const add = x =>
                    y => (x + y)
                // easy !
            </code></pre>
        </section>
        <section>
          <h3>Rappels - this</h3>
          <pre><code data-trim data-noescape>
            function f() {
                this.foo // what is this ?
            }
            </code></pre>
        </section>
        <section>
          <h1>
            <img
              width="200"
              height="200"
              data-src="images/react.svg"
              alt="react"
              style="border: none; background: none; box-shadow: none; margin: 0"
            />
          </h1>
        </section>
        <section>
          <h3>Tout est composant</h3>
          <img data-src="images/components.png" alt="components" width="90%" />
        </section>
        <section>
          <h3>Hello world</h3>
          <pre>Hello.tsx<code data-trim>
            interface Props {
                name: string
            }
            const Hello = (props: Props) => <div>Hello {props.name} !</div>

            export default Hello
            </code></pre>
          <pre class="fragment">index.tsx<code class="jsx" data-trim>
            import { createRoot } from 'react-dom/client'
            import Hello from "./Hello"
            const container = document.getElementById('root')!
            const root = createRoot(container)
            root.render(&lt;Hello name="world" /&gt;)
          </code></pre>
        </section>
        <section>
          <h3>JSX</h3>
          <pre><code data-trim>
            (props: Props) => (
                 &lt;li className="contact"&gt;
                    &lt;h2 className="contact-name"&gt;{props.name}&lt;/h2&gt;
                 &lt;/li&gt;
            )
            </code></pre>
          <pre><code data-trim>
            (props: Props) => React.createElement('li', {className: 'contact'},
                    React.createElement('h2',
                        {className: 'contact-name'}, props.name)
                    )
            )
          </code></pre>
        </section>
        <section data-background="#DEE6F7">
          <h3>TP-01</h3>
          <h4>Hello World</h4>
          <ol>
            <li>Installer l'environnement</li>
            <li>Ecrire le composant Hello</li>
          </ol>
        </section>
        <section>
          <h3>Attributs dans les composants</h3>
          <pre><code data-trim>
            const Counter = () => {
                let count = 0

                return &lt;div onClick={() =&gt; count = count + 1}&gt;
                    Count: {count}
                &lt;/div&gt;
            }
            </code></pre>
          <mark>Don't try this at home !</mark>
        </section>
        <section>
          <h3>State</h3>
          <pre><code data-trim>
           const ComponentWithState = (props) => {
            const [count, setCount] = useState&lt;number&gt;(0)
            const [user, setUser] = useState&lt;User | null&gt;(null)
            const [color, setColor] = useState&lt;string&gt;('green')

            return ...
           }
           </code></pre>
        </section>

        <section>
          <h3>State</h3>
          <p>Pour mettre un état par défaut, on passe un paramètre à useState()</p>
          <pre><code data-trim>
            const [count, setCount] = useState&lt;number&gt;(42)
          </code></pre>
          <p>Mettre à jour un état</p>
          <pre><code data-trim>
            const [count, setCount] = useState&lt;number&gt;(0)
            setCount(10)
            setCount(prevState => prevState + 1)
            </code></pre>
          <p>Récupérer l'état courant</p>
          <pre><code data-trim>
            const [count, setCount] = useState&lt;number&gt;(0)
            count
          </code></pre>
        </section>
        <section>
          <h3>State</h3>
          <pre><code data-trim>
            const Counter = () =>  {
              const [count, setCount] = useState&lt;number&gt;(0)
              return &lt;div onClick={() => setCount(prev => prev + 1)}&gt;
                  Count: {count}
              &lt;/div&gt;
            }
            </code></pre>
        </section>
        <section>
          <h3>Props vs State</h3>

          <p>Props</p>
          <div style="font-size: 30px; text-align: left; margin-left: 50px">
            <ul>
              <li>Données passées par le composant parent</li>
            </ul>
          </div>

          <p>State</p>
          <div style="font-size: 30px; text-align: left; margin-left: 50px">
            <ul>
              <li>Données modifiées par l'utilisateur (clics, saisies, ...)</li>
              <li>Données récupérées d'un web service</li>
              <li>Faire un maximum de composants sans état</li>
              <li><strike>Données dérivées des props </strike>(Faire ca dans le composant directement)</li>
              <li><strike>Composants</strike></li>
            </ul>
          </div>
        </section>
        <section>
          <h3>Class components</h3>
          <pre><code data-trim>
            class ButtonApp extends React.Component {
                state = {count: 0}
                render() {
                    return &lt;div&gt;
                        &lt;div&gt;{this.props.title}&lt;/div&gt;
                        &lt;button&gt;{this.props.label}&lt;/button&gt;
                        &lt;div&gt;{this.state.count}&lt;/div&gt;
                    &lt;/div&gt;
                }
            }
            </code></pre>
        </section>
        <section>
          <h3>Pourquoi les hooks ?</h3>
          <ul>
            <li>Réutiliser la logique entre les composants (sans HOC!)</li>
            <li>
              Composants trop complexes avec les méthodes du cycle de vie (duplication, symétrie cassée sur les
              listeners)
            </li>
            <li>Difficile de lire les classes : this + bind</li>
            <li>Classes se "minifient" mal, le hot reloading est instable</li>
          </ul>
        </section>
        <section>
          <h3>Itérer sur un tableau</h3>
          <pre><code data-trim>
            const MyComponent = (props: Props) => (
                &lt;ul&gt;
                {
                    props.items.map(item =>
                        &lt;li key={item.id}&gt;{item.label}&lt;/li&gt;)
                }
                &lt;/ul&gt;
            )
            </code></pre>
        </section>
        <section>
          <h3>useEffect</h3>
          <p>Déclenche un traitement lorsque des données (issues des props ou des states) changent</p>
          <pre><code data-trim>
            const UserDetails = ({userId}: Props) => {
             const [details, setDetails] = useState&lt;User | null&gt;(null)

             useEffect(() => {
              axios.get&lt;ReadonlyArray&lt;User&gt;&gt;('/users/' + userId)
               .then(({data})) => setDetails(data)
             }, [userId])

             return &lt;div&gt;...
            }
          </code></pre>
        </section>
        <section data-background="#DEE6F7">
          <h3>TP-02</h3>
          <h4>Shopping list</h4>
          <ol style="font-size: 34px">
            <li>Afficher le titre passé par le parent</li>
            <li>Mettre un état par défaut (liste vide)</li>
            <li>Mettre la liste des items retournée par l'appel au web service</li>
            <li>Afficher les items dans une liste &lt;ul&gt;&lt;/ul&gt;</li>
            <li>Créer un composant dédié pour chaque élément de la liste &lt;li&gt;</li>
            <li>
              Bonus: Créer un composant qui fait l'appel ajax, et passe le résultat à un composant enfant, qui lui itère
              sur la liste.
            </li>
          </ol>
        </section>
        <section>
          <h3>Bonus TP-02</h3>
          <pre><code data-trim>
            const ShoppingList = ({title}: Props) => {
               const [items, setItems] = useState&lt;ReadonlyArray&lt;Item&gt;&gt;([])
               // useEffect({...}, [])
               return &lt;ShoppingListInternal title={title}
                        items={items}/&gt;
            }
            const ShoppingListInternal = ({title, items}: Props) =>
            &lt;div&gt;
                &lt;h2&gt;{title}&lt;/h2&gt;
                &lt;ul&gt;{items.map(item =>
                    &lt;ShoppingItem key={item.id} item={item}/&gt;)}
                &lt;/ul&gt;
            &lt;/div&gt;
            </code></pre>
        </section>
        <section>
          <h3>Passer des fonctions dans les props</h3>
          <pre><code data-trim>
            const ShoppingList = ({title}: Props) => {
                const [items, setItems] = useState&lt;ReadonlyArray&lt;User&gt;&gt;([])
                // useEffect({...}, [])

                const deleteItem = (itemIdToDelete: number) => {
                 setItems(prev =>
                    prev.filter(item => item.id !== itemIdToDelete)
                 )
                }
                return (&lt;ShoppingListInternal
                        title={title}
                        items={items}
                        del={deleteItem}/&gt;)
                }
            }
            </code></pre>
        </section>
        <section>
          <h3>Utiliser les fonctions des props</h3>
          <pre><code data-trim>
            const ShoppingListInternal = ({title, items, del}: Props) => (
                &lt;div&gt;
                    &lt;h2&gt;{title}&lt;/h2&gt;
                    &lt;ul&gt;
                        {
                          items.map(item => (&lt;li
                                    onClick={() => del(item.id)}
                                    key={item.id}
                                &gt;
                            {item.label}: {item.price}€
                            &lt;/li&gt;))
                        }
                    &lt;/ul&gt;
                &lt;/div&gt;)
            </code></pre>
        </section>
        <section>
          <h3>Récupérer l'évènement JS</h3>
          <pre><code data-trim>
            const ClickableApp = () => {
                const handleClick = (e: React.MouseEvent&lt;HTMLDivElement&gt;) => {
                    console.log('click !', e)
                }
                return &lt;div onClick={handleClick}&gt;Click me !&lt;/div&gt;
            }
            </code></pre>
          <pre class="fragment"><code data-trim>
            const ClickableApp = () => (
              &lt;div
                onClick={(e: React.MouseEvent&lt;HTMLDivElement&gt;) =>
                 console.log('click !', e)}
              &gt;
                Click me !
              &lt;/div&gt;
            )
          </code></pre>
        </section>
        <section>
          <h3>Avec du style</h3>
        </section>
        <section>
          <h3>inline style vs css</h3>

          <p>Pourquoi ne pas inliner le css dans le js ?</p>

          <pre><code data-trim>
            MyComponent = () => {
                const mystyle = {backgroundColor: '#F0ABCD'}
                return &lt;div style={mystyle}/&gt;
            }
            </code></pre>
          <p>Ou utiliser une css globale, une css par composant (css modules avec Webpack)</p>

          <pre><code data-trim>
            import './MyComponent.css'
          </code></pre>
        </section>
        <section>
          <h3>Ant Design</h3>

          <div style="font-size: 30px; text-align: left; margin-left: 50px">
            <p>React Components for desktop applications</p>
          </div>
          <pre><code data-trim>
            &lt;Button type="primary" onClick={handleClick}&gt;Go!&lt;/Button&gt;
          </code></pre>

          <div style="font-size: 30px; text-align: left; margin-left: 50px">
            <p>Documentation</p>
            <p>
              <a target="_blank" href="https://ant.design/docs/spec/introduce">
                https://ant.design/docs/spec/introduce
              </a>
            </p>
          </div>
        </section>
        <section>
          <h3>Material-UI</h3>

          <div style="font-size: 30px; text-align: left; margin-left: 50px">
            <p>React components that implement Google's Material Design</p>
          </div>
          <pre><code data-trim>
                &lt;Button onClick={handleClick}&gt;Go!&lt;/Button&gt;
          </code></pre>

          <div style="font-size: 30px; text-align: left; margin-left: 50px">
            <p>Documentation</p>
            <p><a target="_blank" href="https://material-ui.com/api/button/">https://material-ui.com/api/button/</a></p>
          </div>
        </section>
        <section>
          <h3>Styled-Components</h3>

          <div style="font-size: 30px; text-align: left; margin-left: 50px">
            <p>Visual primitives for the component age.</p>
          </div>
          <pre><code data-trim>
            const Title = styled.h1`
                font-size: 1.5em;
                text-align: center;
                color: palevioletred;
            `
            &lt;Title&gt;Nice title !&lt;/Title&gt;
            </code></pre>

          <div style="font-size: 30px; text-align: left; margin-left: 50px">
            <p>Documentation</p>
            <p>
              <a target="_blank" href="https://www.styled-components.com/docs/api"
                >https://www.styled-components.com/docs/api</a
              >
            </p>
          </div>
        </section>
        <section>
          <h3>Tips and tricks</h3>
          <h4 class="fragment">(Workarounds)</h4>
        </section>
        <section>
          <h3>Fragments</h3>
          <pre><code data-trim>
            const ComponentWithFragment = () => (
                &lt;&gt;
                    &lt;div&gt;Les&lt;/div&gt;
                    &lt;span&gt;fragments&lt;/span&gt;
                &lt;/&gt;
            )
            </code></pre>
        </section>
        <section>
          <h3>JSX if (else)</h3>
          <p>if</p>
          <pre><code data-trim>
                {user && <div>{user.login}</div>}
            </code></pre>
          <p>not</p>
          <pre><code data-trim>
                {user || <div>No User</div>}
            </code></pre>
          <p>if-else</p>
          <pre><code data-trim>
                {user
                    ? <div>{user.login}</div>
                    : <div>No User</div>}
            </code></pre>
          <p>
            <a href="https://angular.io/api/common/NgIf" style="font-size: 0.5em">Pas mieux en angular :)</a>
          </p>
        </section>
        <section>
          <h3>Commentaires</h3>
          <pre><code data-trim>
            const MyComponent = () => {
                // comment inside JS
                return &lt;div&gt;
                    {/* Comment inside JSX */}
                &lt;/div&gt;
            }
            </code></pre>
        </section>
        <section>
          <h3>Children</h3>

          <pre><code data-trim>
            const container = document.getElementById('root')!
            const root = createRoot(container)
            root.render(
              &lt;ButtonApp title="My Application"&gt;Press Me! &lt;/ButtonApp&gt;
            )
            </code></pre>
          <pre><code data-trim>
            export const ButtonApp = ({title, children}: Props) => {
                return &lt;div&gt;
                    &lt;div&gt;{title}&lt;/div&gt;
                    &lt;button&gt;{children}&lt;/button&gt;
                &lt;/div&gt;
            }
            </code></pre>
        </section>
        <section data-background="#DEE6F7">
          <h3>TP-03</h3>
          <h4>Liste des étudiants</h4>
          <ol>
            <li>Créer un champ "input" qui filtre les éléments de la table</li>
            <li>
              Afficher le nom de l'étudiant sélectionné (Celui sur lequel on a cliqué), ou un message si aucun étudiant
              n'est sélectionné (par défaut)
            </li>
            <li>Bonus : Faire une Pull Request pour faire une <b>jolie</b> correction à ce TP ;)</li>
          </ol>
        </section>
        <section>
          <h3>Ce qu'on a vu jusque là</h3>
          <ul>
            <li>Un composant a des props et des états (states)</li>
            <li>Un composant sans états est plus simple à écrire (et donc plus maintenable)</li>
          </ul>
        </section>
        <section>
          <h3>Flux & Redux</h3>
        </section>
        <section>
          <h3>Flux</h3>
          <div style="font-size: 30px; text-align: left; margin-left: 15px">
            <ul>
              <li>Store: Stocker la donnée</li>
              <li>Action: Mettre à jour le model</li>
              <li>Dispatcher: Aiguiller les actions dans les stores</li>
              <li>View: Composants UI</li>
            </ul>
          </div>
          <img data-src="images/flux.png" alt="flux" />

          <p>Le flux est <i>unidirectionel</i> ! (<strike>2-way binding</strike>)</p>
        </section>
        <section>
          <h3>Bad Practice vs. Good Practice</h3>

          <img data-src="images/flux-bestpractice.png" alt="best practices" height="300" />
          <div style="font-size: 30px; text-align: left; margin-left: 15px">
            <ul>
              <li>On ne met pas à jour les composants directement</li>
              <li>On peut utiliser le store (redux), les stores (flux), les services (RxJs Subjects ), ...</li>
            </ul>
          </div>
        </section>
        <section>
          <h3>Redux</h3>
        </section>
        <section>
          <h3>Redux</h3>
          <pre><code data-trim>
                const userId = window.current_account.id
            </code></pre>
          <p>&laquo; Pourquoi utiliser Redux alors qu'on a déjà les variables globales ? &raquo;</p>
          <p class="fragment">#TROLL</p>
        </section>
        <section>
          <h3>Actions</h3>
          <pre><code data-trim>
                {type: 'INCREMENT', inc: 3}
                {type: 'ADD_TODO', text: 'Buy bread'}
                {type: 'SET_USER', user: new User(1, 'toto')}
            </code></pre>

          <h3>Action Creator</h3>
          <pre><code data-trim>
            export const incrementor = (inc: number): IncAction => {
                return {type: 'INCREMENT', inc}
            }
            </code></pre>
          <pre><code data-trim>
            export const incrementor =
                (inc: number): IncAction => ({type: 'INCREMENT', inc})
            </code></pre>
        </section>
        <section>
          <h3>Redux</h3>

          <div style="font-size: 30px; text-align: left; margin-left: 15px">
            <ul>
              <li>Store unique (plus simple pour l'isomorphisme / SSR)</li>
              <li>Le <b>state</b> du store est read-only</li>
              <li>On dispatch des <b>actions</b> pour mettre à jour le state (du store)</li>
              <li class="fragment">Les <b>actions</b> sont envoyées aux <b>reducers</b></li>
              <li class="fragment">Les <b>reducers</b> sont des fonctions <b>pures</b></li>
              <li class="fragment">Les <b>reducers</b> prennent un état et une action en paramètre</li>
              <li class="fragment">et retournent un nouvel état dans un objet 'immutable'</li>
            </ul>
          </div>
          <img data-src="images/redux.png" alt="redux" height="200" />
        </section>
        <section>
          <h3>Reducer</h3>
          <pre><code data-trim>
            export const counter = (state: number = 0, action: IncAction) => {
                switch (action.type) {
                    case 'INCREMENT':
                        return state + action.inc
                    case 'DECREMENT':
                        return state - action.inc
                    default:
                        return state
                }
            }
            </code></pre>
          Le <b>state</b> est read-only !
          <img data-src="images/redux.png" alt="redux" />
        </section>
        <section>
          <h3>React & Redux</h3>
        </section>
        <section>
          <h3>Composition de Reducers</h3>
          <h4>Approche naïve</h4>
          <pre><code data-trim>
            const initialState: State = {user: '', counter: 0}
            export const myGlobalReducer =
                (state:State = initialState, action: Action): State => {
                    switch (action.type) {
                        case 'SET_USER':
                           return {...state, user: action.user}
                        case 'INCREMENT':
                           return {...state, counter: state.counter + 1}
                        case 'DECREMENT':
                           return {...state, counter: state.counter - 1}
                        default:
                           return state
                }
            }
            </code></pre>
          Pas vraiment lisible pour des applications moyennes ou grosses...!
        </section>
        <section>
          <h3>Composition de reducers</h3>
          <pre><code data-trim>
            export const user =
                (state:User|null = null, action: UserAction): User|null => {
                    switch (action.type) {
                        case 'SET_USER':
                            return action.user
                        default:
                            return state
                    }
                }
            export const counter =
                (state:number = 0, action: IncAction): number => {
                    switch (action.type) {
                        case 'INCREMENT':
                            return state + 1
                        case 'DECREMENT':
                            return state - 1
                        default:
                            return state
                    }
            }
            </code></pre>
        </section>
        <section>
          <h3>Composition de reducers</h3>
          <pre><code data-trim>
            import { combineReducers } from 'redux'
            export const myGlobalReducer = combineReducers({
                user,
                counter
            })
            </code></pre>
        </section>
        <section>
          <h3>Rappels</h3>
          <div style="font-size: 30px; text-align: left; margin-left: 85px">
            <ul>
              <li>Actions</li>
              <li>Reducers</li>
              <li>Store</li>
              <li>Composants React</li>
              <li>Maintenant il fault lier les composants au store</li>
            </ul>
          </div>
          <img data-src="images/redux.png" alt="redux" />
        </section>
        <section>
          <h3>Les Hooks redux</h3>
          <ul>
            <li>Séparation des responsabilités: UI vs tuyauterie</li>
            <li>Le code technique est fait dans les hooks</li>
          </ul>
        </section>
        <section>
          <h3>Hooks</h3>

          <p style="font-size: 28px">useSelector</p>
          <pre><code data-trim>
            import { useTypedSelector } from './reducers'

            export const MyComponent = () => {
              const user = useTypedSelector(state => state.user)
              return &lt;div&gt;{user.id} / {user.email} &lt;/div&gt;
            }
            </code></pre>
          <p style="font-size: 28px">useDispatch</p>
          <pre><code data-trim>
            import { useDispatch } from 'react-redux'

            export const MyComponent = () => {
              const dispatch = useDispatch()
              return &lt;div onClick={() => dispatch({type: 'INC', inc: 1})}&gt;
                Click !
              &lt;/div&gt;
            }
            </code></pre>
        </section>
        <section>
          <h3>Connected component</h3>
          <pre><code data-trim>
          export const SelectPostalCode = () => {
           const dispatch = useDispatch()
           const currentPc = useTypedSelector(state => state.currentPc)
           const postalCodes = useTypedSelector(state => state.postalCodes)

           const handleOnChange =
              (e: React.ChangeEvent&lt;HTMLSelectElement&gt;) => {
            const action = setCurrentPc(e.target.value)
            dispatch(action)
           }
           return (&lt;select onChange={handleOnChange} value={currentPc}&gt;
           {
            postalCodes.map(pc =>
                &lt;option key={pc} value={pc}&gt;{pc}&lt;/option&gt; )
           }
           &lt;/select&gt;)
          }
          </code></pre>
        </section>
        <section>
          <h3>Passer le store à l'application</h3>

          <p>Tous les composants "redux" de l'application doivent avoir accès au store.</p>
          <pre><code data-trim>
                import { createRoot } from 'react-dom/client'
                import {Provider} from 'react-redux'
                import { legacy_createStore as createStore} from 'redux'
                import {reducer} from './reducers/index'
                import {App} from './components/app'

                const container = document.getElementById('root')!
                const root = createRoot(container)
                const store = createStore(reducer)
                root.render(&lt;Provider store={store}&gt;
                        &lt;App/&gt;
                    &lt;/Provider&gt;)

          </code></pre>
        </section>
        <section data-background="#DEE6F7">
          <h3>TP-04</h3>
          <h4>Shopping list - bis</h4>
          <ol style="font-size: 34px">
            <li>Installer redux-dev-tools</li>
            <li>
              Comme le TP-02, mais utiliser le <i>state</i> du store plutot que le <i>state</i> du composant, et
              initialiser la liste (avec un morceau de code synchrone).
            </li>
            <li>Creer un <i>action creator</i> <b>setItems</b> qui retourne une <b>action</b></li>
            <li>Créer un reducer <b>items</b> qui prend une <b>action</b> en entrée</li>
            <li>Créer un global reducer grâce à <b>combineReducer</b></li>
            <li>Créer un boutton qui ajoute un nouvel item à la liste</li>
          </ol>
        </section>
        <section>
          <h3>React Query</h3>
        </section>
        <section>
          <h3>React Query</h3>

          <p>
            React Query permet de faire des requêtes et de stocker le résultat afin qu'il soit disponible dans toute
            l'application.
          </p>
          <pre><code data-trim>
            const { data } = useQuery('items', itemsApi.get)
            </code></pre>
        </section>
        <section>
          <h3>React Query</h3>

          <p>La clé fonctionne également comme un tableau de dépendances.</p>
          <pre><code data-trim>
            const { data } =
                useQuery(['user', userId], () => usersApi.get(userId))
            </code></pre>
        </section>
        <section>
          <h3>React Query</h3>

          <p>useQuery retourne bien plus que les données récupérées.</p>
          <pre><code data-trim>
            const { data = {}, refetch, isLoading, isError } =
                useQuery(['user', userId], () => usersApi.get(userId))
            </code></pre>
          <p>
            Voir la <a href="https://react-query.tanstack.com/reference/useQuery" target="_blank">documentation</a>.
          </p>
        </section>
        <section>
          <h3>React Query</h3>

          <p>Pour faire des mises à jour, on utilise les mutations.</p>
          <pre><code data-trim>
            const { mutateAsync: createUser } = useMutation(userApi.create, {
                onSuccess: () => console.log('c est OK !'),
            })
            </code></pre>
          <pre><code data-trim>
                &lt;button onClick={() => createUser(myNewUser)}&gt;CREATE USER&lt;/button&gt;
            </code></pre>
          <p>
            Voir la <a href="https://react-query.tanstack.com/reference/useMutation" target="_blank">documentation</a>.
          </p>
        </section>
        <section>
          <h3>React Query</h3>

          <p>Il faut initialiser React Query à la racine de l'application</p>
          <pre><code data-trim>
            import { createRoot } from 'react-dom/client'
            import { QueryClient, QueryClientProvider } from 'react-query'

            const container = document.getElementById('root')!
            const root = createRoot(container)
            const queryClient = new QueryClient()

            root.render(&lt;QueryClientProvider client={queryClient}&gt;
                &lt;MyApp/&gt;
              &lt;/QueryClientProvider&gt;)
          </code></pre>
        </section>

        <section data-background="#DEE6F7">
          <h3>TP-05</h3>
          <h4>Shopping list - ter</h4>
          <ol>
            <li>Utiliser useQuery pour récupérer la liste des items (se servir de l'api existante)</li>
            <li>Utiliser useMutation pour ajouter un item à la liste</li>
            <li>Une fois l'ajout fait, utiliser refetch (renvoyé par useQuery) pour recharger la liste</li>
            <li>Utiliser isLoading pour ajouter un loader lors des temps de chargement</li>
          </ol>
        </section>
        <section>
          <h3>Bravo !</h3>
          <p>On sait créer des composants et leur passer des données</p>
          <ul>
            <li>Depuis le composant parent</li>
            <li>Depuis le <i>LocalState</i></li>
            <li>Depuis le <b>store</b></li>
            <li>Avec <b>React Query</b></li>
            <li>Depuis un grand(n)-parent grâce au context...</li>
          </ul>
        </section>
        <section>
          <h3>Context</h3>
        </section>
        <section>
          <h3>Context API</h3>
          <ul>
            <li>On peut passer des données aux composants enfants (partout dans la hiérarchie).</li>
            <li class="fragment">
              Beaucoup de librairires sont basées la dessus. Ce n'était pas une API officielle avant Mars 2018.
            </li>
            <li class="fragment">
              <i>React-redux</i> fonctionne grâce à ça, le store est passé à tous les composants.
            </li>
          </ul>
        </section>
        <section>
          <h3>Context API</h3>
          <p>Créer un <i>Context</i>, et encapsuler l'application à l'interieur du <i>&lt;Context.Provider&gt;</i></p>
          <pre><code data-trim>
                export interface MyContext {
                    color: string
                }
                const MyContext = React.createContext&lt;MyContext&gt;({color: 'red'})
                export default MyContext
            </code></pre>
          <pre><code data-trim>
                ...
                return &lt;MyContext.Provider
                            value={{color: 'blue'}}&gt;
                    &lt;SomeComponent/&gt;
                &lt;/MyContext.Provider&gt;
            </code></pre>
        </section>
        <section>
          <h3>Context API</h3>
          <p>Ensuite on récupère le <i>context</i> là ou l'on veut l'utiliser avec le hook <i>useContext()</i></p>
          <pre><code data-trim>
            import {useContext} from 'react'
            import MyContext from './MyContext'

            const MyComponent = () => {
                const ctx = useContext(MyContext)
                return &lt;div style={{backgroundColor: ctx.color}}&gt;
                   Some text
                &lt;/div&gt;
              }
            }
            </code></pre>
        </section>
        <section data-background="#DEE6F7">
          <h3>TP-06</h3>
          <h4>Context API</h4>
          <p>L'objectif et de passer une couleur et un utilisateur d'un composant parent à un composant 'petit-fils'</p>
          <ol>
            <li>Encapsuer un composant React (Large) dans un Context, avec un User et une couleur.</li>
            <li>Afficher les données du <i>context</i> dans un composant (petit-)enfant (Small)</li>
          </ol>
        </section>
        <section>
          <h3>Tests</h3>
        </section>
        <section>
          <h3>Jest, Enzyme, React Test Renderer, React Testing Library, ...</h3>
          <p style="font-size: 36px">L'idée est de tester les <i>composants</i>, avec leurs états et leurs props.</p>
          <p style="font-size: 36px">L'arrivée des hooks a fait bouger la hiérarchie des outils de test.</p>
          <ul>
            <li style="font-size: 36px">Enzyme: les Hooks ont mis un moment à être supportés</li>
            <li style="font-size: 36px">React test renderer: Pas de façon simple de tester les évènements</li>
            <li style="font-size: 36px">React testing library: Des nouveaux paradigmes sur la façon de tester</li>
          </ul>
        </section>
        <section>
          <h3>Faire le rendu d'un composant</h3>

          <pre><code data-trim>
            import { render } from '@testing-library/react'

            describe('MyComponent', () => {
                it('should work !', () => {
                    render(&lt;MyComponent/&gt;)
                })
            })
            </code></pre>
          <p>
            <a href="https://testing-library.com/docs/react-testing-library/api#render" target="_blank"
              >React Testing Library</a
            >
          </p>
        </section>
        <section>
          <h3>Tester le rendu d'un composant et ses sous-composants, avec les snapshots</h3>
          <pre><code data-trim>
            import { render } from '@testing-library/react'

            it('renders App and its sub components', () => {
                const { container } = render(&lt;App /&gt;)

                expect(container).toMatchSnapshot()
            })
            </code></pre>
        </section>
        <section>
          <h3>Assertions Jest</h3>
          <pre><code data-trim>
            it('tests', () => {
                expect(1 + 1).toEqual(2)
                expect(['a', 'b']).toHaveLength(2)
                expect(0 / 2).not.toBeNaN()
            })
            </code></pre>
          <p>.toEqual(value), .toBeNull(), .toBeTruthy(), .toHaveLength(number), .not.toBeNaN(), ...</p>
          <p><a href="https://jestjs.io/docs/en/expect" target="_blank">Jest</a></p>
        </section>
        <section>
          <h3>Tester le rendu avec des sélecteurs</h3>
          <pre><code data-trim>
            it('should display user infos and winner', () => {
                // Given
                const { container } = render(&lt;Podium first={player4}
                                                     second={player16}
                                                     third={player2} /&gt;)
                const playerInfos = container.querySelector('.infos')
                const winner = container.querySelector('#winner')

                // Then
                expect(playerInfos).toHaveLength(3)
                expect(winner.textContent).toMatch('player4')
            })
            </code></pre>
        </section>
        <section>
          <h3>Rechercher des éléments avec les Queries RTL</h3>
          <pre><code data-trim>
          import {render, screen} from '@testing-library/react'

          it('renders Alarm', () => {
            render(&lt;App/&gt;)
            expect(screen.getByText('Menu Alarme')).toBeTruthy()
            expect(screen.getAllByTestId('alarme')).toHaveLength(2)
            expect(screen.getAllByRole('button')).toHaveLength(2)
          })
          </code></pre>
          <p><a href="https://testing-library.com/docs/queries/about#types-of-queries" target="_blank">Queries</a></p>
        </section>
        <section>
          <h3>Vérifier qu'une méthode a été appelée</h3>
          <pre><code data-trim>
            const mockFunction = jest.fn()
            expect(mockFunction).toHaveBeenCalledWith(42)
          </code></pre>
        </section>
        <section>
          <h3>Simuler des événements</h3>
          <pre><code data-trim>
          import {render, fireEvent, screen } from '@testing-library/react'

          it('fires events', () => {
            render(&lt;NiceInput /&gt;)
            const input = screen.getByRole('input')

            fireEvent.change(input, {target: {value: 'new text'}})
          })
          </code></pre>
        </section>
        <section>
          <h3>Async testing</h3>
          <pre><code data-trim>
          import { render, screen } from '@testing-library/react'

           it('loads data on creation', async () => {
            render(&lt;UserInfo id={42} /&gt;)
            await screen.findByText('Jennifer')

            // expect(...)
          })
          </code></pre>
        </section>
        <section>
          <h3>Mocking avancé avec Jest - functions</h3>
          <pre><code data-trim>
            import { render, screen } from '@testing-library/react'

            jest.mock('api/users', () => ({
              fetchUser: userId =>
                Promise.resolve(new User(userId, 'Jennifer')),
            }))
            describe('UserInfo Component', () => {
              it('should display user ', async () => {
                render(&lt;UserInfo id={42} /&gt;)
                await screen.findByText('Jennifer')

                // expect...
              }
            })
            </code></pre>
        </section>
        <section>
          <h3>Run tests</h3>
          <ul>
            <li><i>npm test</i> in command line</li>
            <li><i>--coverage</i> for test coverage</li>
            <li><i>jest runner</i> in Webstorm / IntelliJ</li>
          </ul>
          <aside class="notes">
            File > Settings > JavaScript > Libraries et Download Jest Typescript definition pour ne plus avoir d'erreurs
            sur 'describe' dans les sources.
          </aside>
        </section>
        <section data-background="#DEE6F7">
          <h3>TP-07</h3>
          <h4>Tests</h4>
          <p>L'objectif est d'écrire les tests du TP-03</p>
          <p></p>
          <ol style="font-size: 32px">
            <li>Créer un fichier .test.js pour chaque composant</li>
            <li><i>StudentDetails</i>: Vérifier les textes (avec Student null ou non)</li>
            <li><i>Filter</i>: Verifier que le callback est appelé quand l'évènement <i>change</i> est propagé</li>
            <li>
              <i>StudentsTable</i>: Vérifier le nombre de ligne dans le tableau, suivant le jeu de données. Tester les
              appels aux callbacks aussi.
            </li>
            <li>
              <i>StudentsApp</i>: Vérifier que les composants sont toujours affichés de la même façon (avec un snapshot)
              . Tester que <i>filteredStudents()</i> retourne une liste filtrée.
            </li>
          </ol>
        </section>
        <section>
          <h3>Routing</h3>
        </section>
        <section>
          <h3>react-router</h3>

          <p>Il y a différents Routers pour gérer l'historique de la navigation et des URLs:</p>
          <ul>
            <li><b>BrowserRouter</b> : /monsite/page1/partie2</li>
            <li><b>HashRouter</b>: /monsite/#/page1/partie2</li>
            <li><b>StaticRouter</b>: Utilisé dans le Server Side Rendering</li>
          </ul>
          <p style="font-size: 24px">
            Pour le BrowserRouter il faut rediriger toutes les requêtes vers index.html, sauf les .css, .js, et les
            appels aux webservices.
          </p>
        </section>
        <section>
          <h3>react-router</h3>

          <p>Il faut définir le routeur à la racine de l'application.</p>
          <pre><code data-trim>
            import {BrowserRouter as Router,
                Routes, Route} from 'react-router-dom'
            import { createRoot } from 'react-dom/client'

            const container = document.getElementById('root')!
            const root = createRoot(container)
            root.render(&lt;Router&gt;
                &lt;Routes>
                  &lt;Route path="/" element={&lt;Home /&gt;} /&gt;
                  &lt;Route path="/about" element={&lt;About /&gt;} /&gt;
                  &lt;Route path="/admin/*" element={&lt;Admin /&gt;} &gt;
                    &lt;Route path="users" element={&lt;UsersAdmin /&gt;} /&gt;
                    &lt;Route path="articles" element={&lt;ArticlesAdmin /&gt;} /&gt;
                  &lt;/Route&gt;
                  &lt;Route path="*" element={&lt;NotFound /&gt;} /&gt;
                &lt;/Routes&gt;
              &lt;/Router&gt;)

            </code></pre>
        </section>
        <section>
          <h3>react-router</h3>
          <p>Plusieurs façons de déclarer les routes :</p>
          <ul>
            <li>
              Déclarer toutes les routes dans un seul composant, comme dans la V3.
              <a
                href="https://reactrouter.com/docs/en/v6/getting-started/overview#multiple-sets-of-routes"
                target="_blank"
                >Exemple</a
              >
            </li>
            <li>
              Déclarer les sous routes dans chaque composant, comme dans les V4-V5.
              <a href="https://reactrouter.com/docs/en/v6/getting-started/overview#descendant-routes" target="_blank"
                >Exemple</a
              >
            </li>
            <li>Mixer les deux stratégies</li>
          </ul>
        </section>
        <section>
          <h3>react-router</h3>
          <p>
            Il est possible de générer les liens automatiquement (voir la documentation)
            <a target="_blank" href="https://reactrouter.com/docs/en/v6/api#link">doc</a> pour l'API
          </p>
          <pre><code data-trim>
            &lt;Link to="/users"&gt;Administration des utilisateurs&lt;/Link&gt;
            </code></pre>
        </section>
        <section>
          <h3>react-router</h3>
          <p>Dynamic urls</p>
          <pre><code data-trim>
            &lt;Route path="users/*" element={&lt;Users /&gt;}&gt;
              &lt;Route path=":userId" element={&lt;UserDetail /&gt;} /&gt;
            &lt;/Route&gt;
            </code></pre>
          <pre><code data-trim>
            const UserDetail = () => {
                const { userId } = useParams()
                return &lt;div&gt;
                        Manage user {userId}
                &lt;/div&gt;
            }
            </code></pre>
        </section>
        <section>
          <h3>react-router</h3>
          <p>
            Lorsque l'on définit les sous routes dans les composants (multiple sets of routes), il faut indiquer dans
            les composants où doivent apparaitrent leurs sous composants. Cela se fait avec &lt;Outlet /&gt;
          </p>
          <pre><code data-trim>
            &lt;Route path="/admin/*" element={&lt;Admin /&gt;} &gt;
              &lt;Route path="users" element={&lt;UsersAdmin /&gt;} /&gt;
              &lt;Route path="articles" element={&lt;ArticlesAdmin /&gt;} /&gt;
            &lt;Route /&gt;
            </code></pre>
          <pre><code data-trim>
            const Admin = () => (
              <div>
                  Bienvenue sur la page d'administration
                  &lt;Outlet /&gt;
              </div>
            )
            </code></pre>
        </section>
        <section data-background="#DEE6F7">
          <h3>TP-08</h3>
          <h4>React-router</h4>
          <p>L'objectif est de construire une application avec 3 "pages".</p>
          <ol style="font-size: 28px">
            <li>Créer les liens vers /about et /users et les routes pour /about et /users</li>
            <li>Créer les liens vers /users/elsa et /users/anna</li>
            <li>Créer la route pour le composant UserDetail (choisir une des deux stratégies)</li>
            <li>Ecrire le lien pour les images de profil (elsa.jpeg and anna.jpeg)</li>
            <li>Créer une route * pour gérer les 404</li>
            <li>Créer une route * pour afficher un message (uniquement) lorsque aucun utilisateur n'est sélectionné</li>
            <li>Bonus : Utiliser NavLink plutôt que Link pour donner un style au lien actif</li>
            <li>Bonus : Utiliser l'autre statégie</li>
          </ol>
        </section>
        <section>
          <h3>Optimisations</h3>
        </section>
        <section>
          <h3>Ne pas faire trop de ré-affichages inutiles</h3>
          <img data-src="images/should-component-update.png" alt="update" />
        </section>
        <section>
          <h3>Reconciliation</h3>
          <p>
            Le <b>Virtual DOM</b> est...
            <span class="fragment" style="font-size: 24px">
              Une représentation mémoire des composants. Quand le rendu d'un composant est fait à nouveau, le nouveau
              V-DOM est comparé à l'ancien V-DOM. Si il y a une différence, le DOM du browser est (partiellement) mis à
              jour.
            </span>
          </p>
        </section>
        <section>
          <h3>Trop de 're-rendering'</h3>
          <ul>
            <li>Memoization</li>
            <li>useCallback()</li>
            <li>useMemo()</li>
          </ul>
        </section>
        <section data-auto-animate data-visibility="hidden">
          <h3 data-id="memo">Perfs - React.memo</h3>
          <p data-id="memo-p">React.memo permet de <em>memoize</em> un composant React.</p>
          <pre data-id="memo-pre"><code data-trim>
           const MyComponent = () => ...
           export default React.memo(MyComponent)
          </code></pre>
        </section>
        <section data-auto-animate>
          <h3 data-id="memo">Perfs - React.memo</h3>
          <p data-id="memo-p">React.memo permet de <em>memoize</em> un composant React.</p>
          <pre data-id="memo-pre"><code data-trim>
           const MyComponent = () => ...
           export default React.memo(MyComponent, (prevProps, nextProps) => {
            return prevProps.user?.id === nextProps.user?.id
           })
          </code></pre>
        </section>
        <section data-auto-animate data-visibility="hidden">
          <h3 data-id="callback">Perfs - useCallback</h3>
          <p data-id="callback-p">
            useCallback permet de ne pas recréer une nouvelle fonction à chaque exécution (re-render) d'un composant.
            Ces fonctions sont destinées à être passées comme callback aux composants enfants.
          </p>
          <pre data-id="callback-pre"><code data-trim>
           const MyComponent = () => (
            &lt;Button onClick={e => console.log(e)}&gt;Click me&lt;/&gt;
           )
          </code></pre>
        </section>
        <section data-auto-animate data-visibility="hidden">
          <h3 data-id="callback">Perfs - useCallback</h3>
          <p data-id="callback-p">
            useCallback permet de ne pas recréer une nouvelle fonction à chaque exécution (re-render) d'un composant.
            Ces fonctions sont destinées à être passées comme callback aux composants enfants.
          </p>
          <pre data-id="callback-pre"><code data-trim>
           const MyComponent = () => {
            const handleClick = (e: SyntheticEvent) => console.log(e)

            return &lt;Button onClick={handleClick}&gt;Click me&lt;/&gt;
           })
          </code></pre>
        </section>
        <section data-auto-animate>
          <h3 data-id="callback">Perfs - useCallback</h3>
          <p data-id="callback-p">
            useCallback permet de ne pas recréer une nouvelle fonction à chaque exécution (re-render) d'un composant.
            Ces fonctions sont destinées à être passées comme callback aux composants enfants.
          </p>
          <pre data-id="callback-pre"><code data-trim>
           const MyComponent = () => {
            const handleClick = useCallback(e => console.log(e), [])

            return &lt;Button onClick={handleClick}&gt;Click me&lt;/&gt;
           })
          </code></pre>
        </section>
        <section data-background="#DEE6F7">
          <h3>TP-09</h3>
          <h4>Optimisations</h4>
          <ul>
            <li>Utiliser la memoization sur le composant Calculator pour éviter le long calcul</li>
            <li>Utiliser useCallback pour éviter au composant Button de se réafficher</li>
          </ul>
        </section>
        <section>
          <h3>Let's do it !</h3>
          <h3>help ? <a href="mailto:jbcazaux@gmail.com">jbcazaux@gmail.com</a></h3>
          <h3><a href="https://formation-reactjs.fr">https://formation-reactjs.fr</a></h3>
        </section>
      </div>
    </div>

    <script src="reveal/reveal.js"></script>
    <script src="reveal/plugin/zoom/zoom.js"></script>
    <script src="reveal/plugin/notes/notes.js"></script>
    <script src="reveal/plugin/search/search.js"></script>
    <script src="reveal/plugin/markdown/markdown.js"></script>
    <script src="reveal/plugin/highlight/highlight.js"></script>
    <script>
      const showHiddenSlides = !window.location.search.match(/print-pdf/gi)
      console.log('showHiddenSlides', showHiddenSlides)
      Reveal.initialize({
        controls: true,
        progress: true,
        center: true,
        hash: true,
        showHiddenSlides,
        pdfSeparateFragments: false,
        plugins: [RevealZoom, RevealNotes, RevealSearch, RevealMarkdown, RevealHighlight],
      })
    </script>
  </body>
</html>
